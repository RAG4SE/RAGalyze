#include <Python.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>
#include "pcre2.h"
// Use local tree-sitter headers
#include "tree_sitter/api.h"

// Global debug flag
static int debug_enabled = 0;

// Enhanced assert function with cleanup and debugging
static void treesitter_assert(int condition, const char* message, void* cleanup_ptr, const char* file, int line) {
    if (!condition) {
        printf("ASSERTION FAILED at %s:%d: %s\n", file, line, message);
        if (cleanup_ptr) {
            free(cleanup_ptr);
        }
        exit(1);
    }
}

// Macro for easier usage with automatic file/line info
#define TREESITTER_ASSERT(condition, message, cleanup_ptr) \
    treesitter_assert(condition, message, cleanup_ptr, __FILE__, __LINE__)

// Macro for asserting pointer allocation
#define ASSERT_ALLOC(ptr, cleanup_ptr) \
    TREESITTER_ASSERT((ptr) != NULL, "Memory allocation failed", cleanup_ptr)

// Debug printf function that only prints when debug mode is enabled
static void debug_printf(const char* format, ...) {
    if (debug_enabled) {
        va_list args;
        va_start(args, format);
        vprintf(format, args);
        va_end(args);
    }
}

static void debug_print_child(TSNode node, const char* source_code) {
    if (debug_enabled) {
        int child_count = ts_node_child_count(node);
        for (uint32_t i = 0; i < child_count; i++) {
            TSNode child = ts_node_child(node, i);
            const char* child_type = ts_node_type(child);
            uint32_t child_start = ts_node_start_byte(child);
            uint32_t child_end = ts_node_end_byte(child);
            size_t child_length = child_end - child_start;
            char* child_text = malloc(child_length + 1);
            if (child_text) {
                memcpy(child_text, source_code + child_start, child_length);
                child_text[child_length] = '\0';
                
                // Get field name if this child has one
                const char* field_name = ts_node_field_name_for_child(node, i);
                if (field_name) {
                    debug_printf("  Child %u: field='%s', type='%s', text='%s'\n", i, field_name, child_type, child_text);
                } else {
                    debug_printf("  Child %u: type='%s', text='%s'\n", i, child_type, child_text);
                }
                free(child_text);
            }
        }
    }
}

static char* concatenate_string(const char* str1, const char* str2) {
    if (!str1 || !str2) {
        printf("DEBUG: concatenate_string called with NULL pointer\n");
        return NULL;
    }
    
    debug_printf("DEBUG: Concatenating '%s' and '%s'\n", str1, str2);
    
    size_t len1 = strlen(str1);
    size_t len2 = strlen(str2);
    size_t total_len = len1 + len2;
    
    char* result = malloc(total_len + 1);
    if (!result) {
        printf("DEBUG: Memory allocation failed for concatenated string\n");
        return NULL;
    }
    
    memcpy(result, str1, len1);
    memcpy(result + len1, str2, len2);
    result[total_len] = '\0';
    
    return result;
}


static TSNode ts_node_child_by_type_name(TSNode node, const char* type_name) {
    for (uint32_t i = 0; i < ts_node_child_count(node); i++) {
        TSNode child = ts_node_child(node, i);
        if (strcmp(ts_node_type(child), type_name) == 0) {
            return child;
        }
    }
    TSNode empty_node = {0};
    return empty_node;
    // treesitter_assert(0, concatenate_string("No child node found with type name: ", type_name), NULL, __FILE__, __LINE__);
}

// Sometimes the declarator sub-field is null, so we need to fallback to the function_declarator type
// For instance,
// DEBUG: Processing declaration type: 'reference_declarator'
// Child 0: type='&', text='&'
// Child 1: type='identifier', text='_handle'
static TSNode fallback_sub_declarator_node_for_cpp(TSNode node) {
    
    treesitter_assert(!ts_node_is_null(node), "No node found", NULL, __FILE__, __LINE__);

    if (!ts_node_is_null(ts_node_child_by_field_name(node, "declarator", 10))) {
        return ts_node_child_by_field_name(node, "declarator", 10);
    }
    else {
        char* type_names[] = {"reference_declarator", "pointer_declarator", "identifier", "field_identifier", "operator_name", "function_declarator", "array_declarator", "qualified_identifier", "field_declaration"};
        for (size_t i = 0; i < sizeof(type_names) / sizeof(type_names[0]); i++) {
            if (!ts_node_is_null(ts_node_child_by_type_name(node, type_names[i]))) {
                return ts_node_child_by_type_name(node, type_names[i]);
            }
        }
    }
}

static char* normalize_function_name(const char* func_name) {
    // Check if it's a method call (contains dot or arrow)
    char* method_start = func_name;
    if (strchr(func_name, '.') || strchr(func_name, '>')) {
        // Extract just the method name after the last dot or arrow
        char* last_dot = strrchr(func_name, '.');
        char* last_arrow = strrchr(func_name, '>');
        method_start = (last_arrow > last_dot) ? last_arrow + 1 : (last_dot ? last_dot + 1 : func_name);
    }
    if (strchr(method_start, '(')) {
        // Trim off parameters if present
        char* paren = strchr(method_start, '(');
        *paren = '\0';
    }
    return method_start;
}

// Simple logging function for tree-sitter parser
static void treesitter_log_callback(void *payload, TSLogType type, const char *message) {
    (void)payload; // Unused
    (void)type;    // Unused for now
    printf("[TREESITTER] %s\n", message);
}

const TSLanguage* tree_sitter_cpp(void);
const TSLanguage* tree_sitter_python(void);
const TSLanguage* tree_sitter_c(void);
const TSLanguage* tree_sitter_java(void);
const TSLanguage* tree_sitter_javascript(void);
const TSLanguage* tree_sitter_xml(void);

// Helper to get language parser
static const TSLanguage* get_language(const char* language_name) {
    if (language_name == NULL) {
        return NULL;
    }
    
    // Import language parsers - these would be linked at compile time
    
    // Return the appropriate language parser
    if (strcmp(language_name, "cpp") == 0) {
        debug_printf("Using C++ parser\n");
        return tree_sitter_cpp();
    } else if (strcmp(language_name, "python") == 0) {
        debug_printf("Using Python parser\n");
        return tree_sitter_python();
    } else if (strcmp(language_name, "c") == 0) {
        debug_printf("Using C++ parser\n");
        return tree_sitter_cpp();
    } else if (strcmp(language_name, "java") == 0) {
        debug_printf("Using Java parser\n");
        return tree_sitter_java();
    } else if (strcmp(language_name, "javascript") == 0) {
        debug_printf("Using JavaScript parser\n");
        return tree_sitter_javascript();
    } else if (strcmp(language_name, "xml") == 0) {
        debug_printf("Using XML parser\n");
        return tree_sitter_xml();
    }

    return NULL;
}

// Structure to represent parsing results
typedef struct {
    char** node_types;
    char** node_texts;
    size_t count;
    size_t capacity;
} ParseResults;

// Structure to represent tokenized results for BM25
typedef struct {
    char** tokens;
    size_t count;
    size_t capacity;
} TokenResults;

// Language parser mapping
typedef struct {
    const char* name;
    const TSLanguage* (*parser_func)(void);
} LanguageMapping;

// Function to initialize parse results
static ParseResults* init_parse_results() {
    ParseResults* results = malloc(sizeof(ParseResults));
    if (!results) {
        return NULL;
    }
    
    results->capacity = 50;
    results->count = 0;
    results->node_types = malloc(results->capacity * sizeof(char*));
    results->node_texts = malloc(results->capacity * sizeof(char*));
    
    if (!results->node_types || !results->node_texts) {
        free(results->node_types);
        free(results->node_texts);
        free(results);
        return NULL;
    }
    
    return results;
}

// Function to add a node to results
static void add_node(ParseResults* results, const char* type, const char* text) {
    if (results->count >= results->capacity) {
        results->capacity *= 2;
        results->node_types = realloc(results->node_types, results->capacity * sizeof(char*));
        results->node_texts = realloc(results->node_texts, results->capacity * sizeof(char*));
    }
    
    results->node_types[results->count] = strdup(type);
    results->node_texts[results->count] = strdup(text);
    results->count++;
}

// Function to free parse results
static void free_parse_results(ParseResults* results) {
    for (size_t i = 0; i < results->count; i++) {
        free(results->node_types[i]);
        free(results->node_texts[i]);
    }
    free(results->node_types);
    free(results->node_texts);
    free(results);
}

// Function to initialize token results
static TokenResults* init_token_results() {
    TokenResults* results = malloc(sizeof(TokenResults));
    results->capacity = 100;
    results->count = 0;
    results->tokens = malloc(results->capacity * sizeof(char*));
    return results;
}

// Function to add a token
static void add_token(TokenResults* results, const char* token) {
    if (results->count >= results->capacity) {
        results->capacity *= 2;
        results->tokens = realloc(results->tokens, results->capacity * sizeof(char*));
    }
    results->tokens[results->count] = strdup(token);
    results->count++;
}

// Function to free token results
static void free_token_results(TokenResults* results) {
    for (size_t i = 0; i < results->count; i++) {
        free(results->tokens[i]);
    }
    free(results->tokens);
    free(results);
}

static char* get_node_text(TSNode node, const char* source_code) {
    uint32_t start_byte = ts_node_start_byte(node);
    uint32_t end_byte = ts_node_end_byte(node);
    size_t text_length = end_byte - start_byte;
    char* node_text = malloc(text_length + 1);
    memcpy(node_text, source_code + start_byte, text_length);
    node_text[text_length] = '\0';
    return node_text;
}

static void traverse_tree(TSNode node, const char* source_code, ParseResults* results, const char* language_name);

// Recursive function to process C++ declarations
static void traverse_declaration_cpp(TSNode name_declarator, const char* source_code, ParseResults* results, const char* language_name, bool is_function_declarator) {
    const char* decl_type = ts_node_type(name_declarator);
    debug_printf("DEBUG: Processing declaration type: '%s'\n", decl_type);
    debug_print_child(name_declarator, source_code);

    // Handle init_declarator (e.g., int i = 1;)
    if (strcmp(decl_type, "init_declarator") == 0) {
        TSNode sub_declarator = fallback_sub_declarator_node_for_cpp(name_declarator);
        treesitter_assert(!ts_node_is_null(sub_declarator), "No declarator field found", NULL, __FILE__, __LINE__);
        const char* declarator_name = get_node_text(sub_declarator, source_code);
        free(declarator_name);
        traverse_declaration_cpp(sub_declarator, source_code, results, language_name, is_function_declarator);

        TSNode value_node = ts_node_child_by_field_name(name_declarator, "value", 5);
        treesitter_assert(!ts_node_is_null(value_node), "No value field found", NULL, __FILE__, __LINE__);
        traverse_tree(value_node, source_code, results, language_name);
    }
    else if (strcmp(decl_type, "identifier") == 0 || strcmp(decl_type, "field_identifier") == 0 || strcmp(decl_type, "operator_name") == 0) {
        // Simple identifier (e.g., int i;)
        const char* declarator_name = get_node_text(name_declarator, source_code);
        debug_printf("DEBUG: Found var declaration: '%s'\n", declarator_name);
        if (is_function_declarator) {
            add_node(results, "func_declaration", declarator_name);
        }
        else {
            add_node(results, "var_declaration", declarator_name);
        }
        free(declarator_name);
    }
    else if (strcmp(decl_type, "function_declarator") == 0) {
        // Function declaration (e.g., void method();)
        TSNode parameters_node = ts_node_child_by_field_name(name_declarator, "parameters", 10);
        if (!ts_node_is_null(parameters_node)) {
            traverse_tree(parameters_node, source_code, results, language_name);
        }

        TSNode sub_declarator = fallback_sub_declarator_node_for_cpp(name_declarator);
        treesitter_assert(!ts_node_is_null(sub_declarator), "No declarator field found", NULL, __FILE__, __LINE__);

        const char* declarator_name = get_node_text(sub_declarator, source_code);
        debug_printf("DEBUG: Found function declaration: '%s'\n", declarator_name);
        free(declarator_name);
        traverse_declaration_cpp(sub_declarator, source_code, results, language_name, true);
    }
    else if (strcmp(decl_type, "array_declarator") == 0) {
        // Array declaration (e.g., int arr[100];)
        TSNode sub_declarator = fallback_sub_declarator_node_for_cpp(name_declarator);
        treesitter_assert(!ts_node_is_null(sub_declarator), "No declarator field found", NULL, __FILE__, __LINE__);
        traverse_declaration_cpp(sub_declarator, source_code, results, language_name, is_function_declarator);
    }
    else if (strcmp(decl_type, "pointer_declarator") == 0 ||
             strcmp(decl_type, "reference_declarator") == 0) {
        // Pointer or reference declaration (e.g., int* i; int& i;)
        TSNode sub_declarator = fallback_sub_declarator_node_for_cpp(name_declarator);
        treesitter_assert(!ts_node_is_null(sub_declarator), "No declarator field found", NULL, __FILE__, __LINE__);
        traverse_declaration_cpp(sub_declarator, source_code, results, language_name, is_function_declarator);
    }
    else if (strcmp(decl_type, "qualified_identifier") == 0) {
        // Qualified identifier (e.g., Class::method)
        const char* full_name = get_node_text(name_declarator, source_code);
        debug_printf("DEBUG: Found qualified declaration: '%s'\n", full_name);
        if (is_function_declarator) {
            add_node(results, "func_declaration", full_name);
        }
        else {
            add_node(results, "var_declaration", full_name);
        }
        free(full_name);
        TSNode sub_declarator = ts_node_child_by_field_name(name_declarator, "name", 4);
        traverse_declaration_cpp(sub_declarator, source_code, results, language_name, is_function_declarator);
    }
    else if (strcmp(decl_type, "field_declaration") == 0) {
        // Field declaration (e.g., int i;)
        TSNode sub_declarator = fallback_sub_declarator_node_for_cpp(name_declarator);
        treesitter_assert(!ts_node_is_null(sub_declarator), "No declarator field found", NULL, __FILE__, __LINE__);
        traverse_declaration_cpp(sub_declarator, source_code, results, language_name, is_function_declarator);
    }
    else {
        treesitter_assert(0, concatenate_string("Invalid declarator type: ", decl_type), NULL, __FILE__, __LINE__);
    }
}

// Recursive function to traverse the AST
static void traverse_tree(TSNode node, const char* source_code, ParseResults* results, const char* language_name) {
    uint32_t child_count = ts_node_child_count(node);
    // Get node type and text
    const char* node_type = ts_node_type(node);
    
    // Debug: print all node types to see what we're getting
    // Get start and end points
    uint32_t start_byte = ts_node_start_byte(node);
    uint32_t end_byte = ts_node_end_byte(node);
    // Extract text
    size_t text_length = end_byte - start_byte;
    char* node_text = malloc(text_length + 1);
    //@haoyang9804: comment it off later
    // Print node text and child count (for debugging)
    if (node_text == NULL) {
        // Handle allocation failure
        exit(1);
    }
    memcpy(node_text, source_code + start_byte, text_length);
    node_text[text_length] = '\0';
    debug_printf("DEBUG: Node type: '%s', NODE TEXT: '%s'\n", node_type, node_text);


    if (strcmp(language_name, "python") == 0) {
        if (strcmp(node_type, "function_definition") == 0) {

            debug_printf("DEBUG: Function definition child nodes:\n");
            debug_print_child(node, source_code);
            
            TSNode name_node = ts_node_child_by_field_name(node, "name", 4);
            TSNode parameters_node = ts_node_child_by_field_name(node, "parameters", 10);
            TSNode body_node = ts_node_child_by_field_name(node, "body", 4);

            treesitter_assert(!ts_node_is_null(name_node), "No name field found", node_text, __FILE__, __LINE__);
            treesitter_assert(!ts_node_is_null(parameters_node), "No parameters field found", node_text, __FILE__, __LINE__);
            treesitter_assert(!ts_node_is_null(body_node), "No body field found", node_text, __FILE__, __LINE__);

            const char* func_name = get_node_text(name_node, source_code);
            debug_printf("DEBUG: Found Python function definition via name field: '%s'\n", func_name);
            add_node(results, "function_definition", func_name);
            free(func_name);

            traverse_tree(parameters_node, source_code, results, language_name);
            traverse_tree(body_node, source_code, results, language_name);
            return;
        }

        else if (node_type == "class_definition") {
            debug_printf("DEBUG: Class definition child nodes:\n");
            debug_print_child(node, source_code);
            
            TSNode name_node = ts_node_child_by_field_name(node, "name", 4);
            TSNode body_node = ts_node_child_by_field_name(node, "body", 4);

            treesitter_assert(!ts_node_is_null(name_node), "No name field found", node_text, __FILE__, __LINE__);
            treesitter_assert(!ts_node_is_null(body_node), "No body field found", node_text, __FILE__, __LINE__);

            const char* class_name = get_node_text(name_node, source_code);
            debug_printf("DEBUG: Found Python class definition via name field: '%s'\n", class_name);
            add_node(results, "class_definition", class_name);
            free(class_name);

            traverse_tree(body_node, source_code, results, language_name);
            return;
        }

        else if (node_type == "call") {
            debug_printf("DEBUG: Call expression child nodes:\n");
            debug_print_child(node, source_code);

            TSNode function_node = ts_node_child_by_field_name(node, "function", 8);
            TSNode arguments_node = ts_node_child_by_field_name(node, "arguments", 9);

            treesitter_assert(!ts_node_is_null(function_node), "No function field found", node_text, __FILE__, __LINE__);
            treesitter_assert(!ts_node_is_null(arguments_node), "No arguments field found", node_text, __FILE__, __LINE__);

            debug_printf("DEBUG: Function node type: '%s'\n", ts_node_type(function_node));
            debug_print_child(function_node, source_code);

            if (strcmp(ts_node_type(function_node), "attribute") == 0) {
                TSNode object_node = ts_node_child_by_field_name(function_node, "object", 6);
                treesitter_assert(!ts_node_is_null(object_node), "No object field found", node_text, __FILE__, __LINE__);
                function_node = ts_node_child_by_field_name(function_node, "attribute", 9);
                treesitter_assert(!ts_node_is_null(function_node), "No field field found", node_text, __FILE__, __LINE__);
                traverse_tree(object_node, source_code, results, language_name);
            }

            const char* func_name = get_node_text(function_node, source_code);
            debug_printf("DEBUG: Found Python call expression via function field: '%s'\n", func_name);
            add_node(results, "call", func_name);
            free(func_name);

            traverse_tree(arguments_node, source_code, results, language_name);
            return;
        }

        else if (node_type == "identifier" || node_type == "field_identifier") {
            debug_printf("DEBUG: Identifier\n");

            const char* name = get_node_text(node, source_code);
            debug_printf("DEBUG: Found Python identifier: '%s'\n", name);
            add_node(results, "identifier", name);
            free(name);
            return;
        }
    }

    else if (strcmp(language_name, "cpp") == 0 || strcmp(language_name, "c") == 0) {
        if (strcmp(node_type, "function_definition") == 0) {
            debug_printf("DEBUG: Function definition child nodes:\n");
            debug_print_child(node, source_code);

            TSNode declarator_node = ts_node_child_by_field_name(node, "declarator", 10);
            treesitter_assert(!ts_node_is_null(declarator_node), "No declarator field found", node_text, __FILE__, __LINE__);
            debug_printf("DEBUG: Function declarator node's child nodes:\n");
            debug_print_child(declarator_node, source_code);

            // Recursively resolve the actual function declarator
            TSNode function_declarator = declarator_node;
            while (1) {
                const char* decl_type = ts_node_type(function_declarator);
                debug_printf("DEBUG: Processing declarator type: '%s'\n", decl_type);
                debug_print_child(function_declarator, source_code);

                if (strcmp(decl_type, "function_declarator") == 0) {
                    break;  // Found the actual function declarator
                }
                else if (strcmp(decl_type, "reference_declarator") == 0 ||
                         strcmp(decl_type, "pointer_declarator") == 0) {
                    // Move to the child declarator
                    function_declarator = fallback_sub_declarator_node_for_cpp(function_declarator);
                    
                    treesitter_assert(!ts_node_is_null(function_declarator), "No nested declarator found", node_text, __FILE__, __LINE__);
                }
                else {
                    treesitter_assert(0, concatenate_string("Invalid function declarator type: ", decl_type), node_text, __FILE__, __LINE__);
                }
            }

            TSNode parameters_node = ts_node_child_by_field_name(function_declarator, "parameters", 10);
            treesitter_assert(!ts_node_is_null(parameters_node), "No parameters field found", node_text, __FILE__, __LINE__);
            traverse_tree(parameters_node, source_code, results, language_name);

            // Get the actual function name (recursively if needed)
            TSNode name_node = ts_node_child_by_field_name(function_declarator, "declarator", 10);
            treesitter_assert(!ts_node_is_null(name_node), "No declarator field found in function_declarator", node_text, __FILE__, __LINE__);

            // Handle cases where the name is nested in pointer/reference declarators
            while (strcmp(ts_node_type(name_node), "pointer_declarator") == 0 ||
                   strcmp(ts_node_type(name_node), "reference_declarator") == 0) {
                name_node = ts_node_child_by_field_name(name_node, "declarator", 10);
                treesitter_assert(!ts_node_is_null(name_node), "No nested declarator found for name", node_text, __FILE__, __LINE__);
            }

            if (strcmp(ts_node_type(name_node), "qualified_identifier") == 0) {
                TSNode short_name_node = ts_node_child_by_field_name(name_node, "name", 4);
                treesitter_assert(!ts_node_is_null(short_name_node), "No name field found", node_text, __FILE__, __LINE__);
                const char* short_func_name = get_node_text(short_name_node, source_code);
                debug_printf("DEBUG: Found Python function definition via name field: '%s'\n", short_func_name);
                add_node(results, "function_definition", short_func_name);
                free(short_func_name);
            }

            const char* func_name = get_node_text(name_node, source_code);
            debug_printf("DEBUG: Found function definition via declarator field: '%s'\n", func_name);

            add_node(results, "function_definition", func_name);
            free(func_name);

            TSNode body_node = ts_node_child_by_field_name(node, "body", 4);
            treesitter_assert(!ts_node_is_null(body_node), "No body field found", node_text, __FILE__, __LINE__);

            traverse_tree(body_node, source_code, results, language_name);
            return;
        }
        else if (strcmp(node_type, "class_specifier") == 0 || strcmp(node_type, "struct_specifier") == 0) {
            debug_printf("DEBUG: Class definition child nodes:\n");
            debug_print_child(node, source_code);

            TSNode name_node = ts_node_child_by_field_name(node, "name", 4);
            treesitter_assert(!ts_node_is_null(name_node), "No name field found", node_text, __FILE__, __LINE__);

            const char* class_name = get_node_text(name_node, source_code);
            debug_printf("DEBUG: Found class definition via name field: '%s'\n", class_name);
            add_node(results, "class_definition", class_name);
            free(class_name);

            TSNode body_node = ts_node_child_by_field_name(node, "body", 4);
            treesitter_assert(!ts_node_is_null(body_node), "No body field found", node_text, __FILE__, __LINE__);

            traverse_tree(body_node, source_code, results, language_name);
            return;
        }
        else if (strcmp(node_type, "call_expression") == 0) {
            debug_printf("DEBUG: Call expression child nodes:\n");
            debug_print_child(node, source_code);

            TSNode function_node = ts_node_child_by_field_name(node, "function", 8);
            treesitter_assert(!ts_node_is_null(function_node), "No function field found", node_text, __FILE__, __LINE__);
            TSNode name_node;
            if (strcmp(ts_node_type(function_node), "field_expression") == 0) {
                name_node = ts_node_child_by_field_name(function_node, "field", 5);
                treesitter_assert(!ts_node_is_null(name_node), "No field field found", node_text, __FILE__, __LINE__);
                TSNode arguments_node = ts_node_child_by_field_name(function_node, "argument", 8);
                treesitter_assert(!ts_node_is_null(arguments_node), "No argument field found", node_text, __FILE__, __LINE__);
                traverse_tree(arguments_node, source_code, results, language_name);
            }
            else if (strcmp(ts_node_type(function_node), "identifier") == 0) {
                name_node = function_node;
            }
            else if (strcmp(ts_node_type(function_node), "qualified_identifier") == 0) {
                const char* qualified_func_name = get_node_text(function_node, source_code);
                debug_printf("DEBUG: Found qualified function name: '%s'\n", qualified_func_name);
                add_node(results, "call", qualified_func_name);
                free(qualified_func_name);
                name_node = ts_node_child_by_field_name(function_node, "name", 4);
                treesitter_assert(!ts_node_is_null(name_node), "No name field found", node_text, __FILE__, __LINE__);
            }
            else {
                treesitter_assert(0, "Invalid function type", node_text, __FILE__, __LINE__);
            }
            const char* func_name = get_node_text(name_node, source_code);
            debug_printf("DEBUG: Found call expression via function field: '%s'\n", func_name);
            add_node(results, "call", func_name);
            free(func_name);

            TSNode arguments_node = ts_node_child_by_field_name(node, "arguments", 9);
            treesitter_assert(!ts_node_is_null(arguments_node), "No argument field found", node_text, __FILE__, __LINE__);
            traverse_tree(arguments_node, source_code, results, language_name);
            return;
        }
        else if (strcmp(node_type, "declaration") == 0 || strcmp(node_type, "parameter_declaration") == 0 || strcmp(node_type, "pointer_declaration") == 0 || strcmp(node_type, "field_declaration") == 0 || strcmp(node_type, "field_declaration") == 0) {
            debug_printf("DEBUG: Declarations's child nodes:\n");
            debug_print_child(node, source_code);

            TSNode declarator_node = ts_node_child_by_field_name(node, "declarator", 10);
            treesitter_assert(!ts_node_is_null(declarator_node), "No declarator field found", node_text, __FILE__, __LINE__);

            // Use the recursive function to process the declarator
            traverse_declaration_cpp(declarator_node, source_code, results, language_name, false);

            return;
        }
        else if (strcmp(node_type, "identifier") == 0) {
            debug_printf("DEBUG: Identifier\n");

            const char* name = get_node_text(node, source_code);
            debug_printf("DEBUG: Found C++ identifier: '%s'\n", name);
            add_node(results, "identifier", name);
            free(name);
            return;
        }
        else if (strcmp(node_type, "new_expression") == 0) {
            debug_printf("DEBUG: New expression's child nodes:\n");
            debug_print_child(node, source_code);
            TSNode type_node = ts_node_child_by_field_name(node, "type", 4);
            TSNode arguments_node = ts_node_child_by_field_name(node, "arguments", 9);
            treesitter_assert(!ts_node_is_null(type_node), "No type field found", node_text, __FILE__, __LINE__);
            const char* type_name = get_node_text(type_node, source_code);
            debug_printf("DEBUG: Found C++ new expression's type: '%s'\n", type_name);
            add_node(results, "object_creation", type_name);
            if (!ts_node_is_null(arguments_node)) {
                traverse_tree(arguments_node, source_code, results, language_name);
            }
            free(type_name);
            return;
        }
    }

    else if (strcmp(language_name, "java") == 0) {
        if (strcmp(node_type, "method_declaration") == 0 || strcmp(node_type, "constructor_declaration") == 0) {
            debug_printf("DEBUG: Method declaration child nodes:\n");
            debug_print_child(node, source_code);

            TSNode name_node = ts_node_child_by_field_name(node, "name", 4);
            TSNode parameters_node = ts_node_child_by_field_name(node, "parameters", 10);
            // java's method_declaration can be both definition and declaration
            // so we need to check if the body is null later
            TSNode body_node = ts_node_child_by_field_name(node, "body", 4);

            treesitter_assert(!ts_node_is_null(name_node), "No name field found", node_text, __FILE__, __LINE__);
            treesitter_assert(!ts_node_is_null(parameters_node), "No parameters field found", node_text, __FILE__, __LINE__);

            const char* method_name = get_node_text(name_node, source_code);
            debug_printf("DEBUG: Found Java method declaration via name field: '%s'\n", method_name);
            add_node(results, "function_definition", method_name);
            free(method_name);

            traverse_tree(parameters_node, source_code, results, language_name);
            if (!ts_node_is_null(body_node)) {
                traverse_tree(body_node, source_code, results, language_name);
            }
            return;
        }
        else if (strcmp(node_type, "class_declaration") == 0) {
            debug_printf("DEBUG: Class declaration child nodes:\n");
            debug_print_child(node, source_code);

            TSNode name_node = ts_node_child_by_field_name(node, "name", 4);
            TSNode body_node = ts_node_child_by_field_name(node, "body", 4);

            treesitter_assert(!ts_node_is_null(name_node), "No name field found", node_text, __FILE__, __LINE__);
            treesitter_assert(!ts_node_is_null(body_node), "No body field found", node_text, __FILE__, __LINE__);

            const char* class_name = get_node_text(name_node, source_code);
            debug_printf("DEBUG: Found Java class declaration via name field: '%s'\n", class_name);
            add_node(results, "class_definition", class_name);
            free(class_name);

            traverse_tree(body_node, source_code, results, language_name);
            return;
        }
        else if (strcmp(node_type, "interface_declaration") == 0) {
            debug_printf("DEBUG: Interface declaration child nodes:\n");
            debug_print_child(node, source_code);

            TSNode name_node = ts_node_child_by_field_name(node, "name", 4);
            TSNode body_node = ts_node_child_by_field_name(node, "body", 4);

            treesitter_assert(!ts_node_is_null(name_node), "No name field found", node_text, __FILE__, __LINE__);
            treesitter_assert(!ts_node_is_null(body_node), "No body field found", node_text, __FILE__, __LINE__);

            const char* interface_name = get_node_text(name_node, source_code);
            debug_printf("DEBUG: Found Java interface declaration via name field: '%s'\n", interface_name);
            add_node(results, "class_definition", interface_name);
            free(interface_name);

            traverse_tree(body_node, source_code, results, language_name);
            return;
        }
        else if (strcmp(node_type, "method_invocation") == 0) {
            debug_printf("DEBUG: Method invocation child nodes:\n");
            debug_print_child(node, source_code);

            TSNode name_node = ts_node_child_by_field_name(node, "name", 4);
            TSNode arguments_node = ts_node_child_by_field_name(node, "arguments", 9);
            TSNode object_node = ts_node_child_by_field_name(node, "object", 6);

            treesitter_assert(!ts_node_is_null(name_node), "No name field found", node_text, __FILE__, __LINE__);
            treesitter_assert(!ts_node_is_null(arguments_node), "No arguments field found", node_text, __FILE__, __LINE__);

            const char* method_name = get_node_text(name_node, source_code);
            debug_printf("DEBUG: Found Java method invocation via name field: '%s'\n", method_name);
            add_node(results, "call", method_name);
            free(method_name);

            traverse_tree(arguments_node, source_code, results, language_name);
            if (!ts_node_is_null(object_node)) {
                traverse_tree(object_node, source_code, results, language_name);
            }
            return;
        }
        else if (strcmp(node_type, "field_declaration") == 0) {
            debug_printf("DEBUG: Field declaration child nodes:\n");
            debug_print_child(node, source_code);

            TSNode declarator_node = node;
            while(!ts_node_is_null(ts_node_child_by_field_name(declarator_node, "declarator", 10))) {
                declarator_node = ts_node_child_by_field_name(node, "declarator", 10);
            }
            TSNode name_node = ts_node_child_by_field_name(declarator_node, "name", 4);
            const char* var_name = get_node_text(name_node, source_code);
            debug_printf("DEBUG: Found Java local variable declaration: '%s'\n", var_name);
            add_node(results, "var_declaration", var_name);
            free(var_name);
            if (!ts_node_is_null(ts_node_child_by_field_name(declarator_node, "value", 5))) {
                debug_print_child(ts_node_child_by_field_name(declarator_node, "value", 5), source_code);
                traverse_tree(ts_node_child_by_field_name(declarator_node, "value", 5), source_code, results, language_name);
            }
            return;
        }
        else if (strcmp(node_type, "local_variable_declaration") == 0) {
            debug_printf("DEBUG: Local variable declaration child nodes:\n");
            debug_print_child(node, source_code);
            TSNode declarator_node = node;
            while(!ts_node_is_null(ts_node_child_by_field_name(declarator_node, "declarator", 10))) {
                declarator_node = ts_node_child_by_field_name(node, "declarator", 10);
            }
            TSNode name_node = ts_node_child_by_field_name(declarator_node, "name", 4);
            const char* var_name = get_node_text(name_node, source_code);
            debug_printf("DEBUG: Found Java local variable declaration: '%s'\n", var_name);
            add_node(results, "var_declaration", var_name);
            free(var_name);
            if (!ts_node_is_null(ts_node_child_by_field_name(declarator_node, "value", 5))) {
                traverse_tree(ts_node_child_by_field_name(declarator_node, "value", 5), source_code, results, language_name);
            }
            return;
        }
        else if (strcmp(node_type, "object_creation_expression") == 0) {
            // new type_name(argument1, argument2, ...);
            debug_printf("DEBUG: Object creation expression\n");
            debug_print_child(node, source_code);
            TSNode type_node = ts_node_child_by_field_name(node, "type", 4);
            TSNode arguments_node = ts_node_child_by_field_name(node, "arguments", 9);
            treesitter_assert(!ts_node_is_null(type_node), "No type field found", node_text, __FILE__, __LINE__);
            const char* type_name = get_node_text(type_node, source_code);
            debug_printf("DEBUG: Found Java object creation expression: '%s'\n", type_name);
            add_node(results, "object_creation", type_name);
            if (!ts_node_is_null(arguments_node)) {
                traverse_tree(arguments_node, source_code, results, language_name);
            }
            free(type_name);
            return;
        }
        else if (strcmp(node_type, "identifier") == 0) {
            debug_printf("DEBUG: Identifier\n");

            const char* name = get_node_text(node, source_code);
            debug_printf("DEBUG: Found Java identifier: '%s'\n", name);
            add_node(results, "identifier", name);
            free(name);
            return;
        }
    }

    else {
        treesitter_assert(0, concatenate_string("Unsupported language: ", language_name), node_text, __FILE__, __LINE__);
        free(node_text);
        return;
    }

    free(node_text);
    // Recursively traverse children
    for (uint32_t i = 0; i < child_count; i++) {
        TSNode child = ts_node_child(node, i);
        traverse_tree(child, source_code, results, language_name);
    }
}

// Fallback parser equivalent to tokens = re.findall(r"\b\w+\b", text) using PCRE2
static ParseResults* fallback_parse(const char* code, const char* language_name) {
    ParseResults* results = init_parse_results();
    
    // PCRE2 pattern equivalent to Python's \b\w+\b
    // Using word boundary and word character with proper options
    const char* pattern = "\\b[a-zA-Z0-9_]+\\b";
    PCRE2_SPTR subject = (PCRE2_SPTR)code;
    PCRE2_SPTR pattern_ptr = (PCRE2_SPTR)pattern;
    
    int errorcode;
    PCRE2_SIZE erroroffset;
    pcre2_code *re = pcre2_compile(
        pattern_ptr,
        PCRE2_ZERO_TERMINATED,
        PCRE2_UCP | PCRE2_UTF | PCRE2_ALT_BSUX,
        &errorcode,
        &erroroffset,
        NULL
    );
    
    if (!re) {
        // Get error message and raise error
        PCRE2_UCHAR error_message[256];
        pcre2_get_error_message(errorcode, error_message, sizeof(error_message));
        fprintf(stderr, "PCRE2 compilation failed at offset %d: %s\n", (int)erroroffset, error_message);
        exit(1);
    }
    
    pcre2_match_data *match_data = pcre2_match_data_create_from_pattern(re, NULL);
    if (!match_data) {
        pcre2_code_free(re);
        fprintf(stderr, "Failed to create PCRE2 match data\n");
        exit(1);
    }
    
    int rc;
    size_t subject_len = strlen(code);
    size_t start_offset = 0;
    
    while (start_offset < subject_len &&
           (rc = pcre2_match(
               re,
               subject,
               subject_len,
               start_offset,
               0,
               match_data,
               NULL
           )) >= 0) {
        
        PCRE2_SIZE *ovector = pcre2_get_ovector_pointer(match_data);
        
        if (rc > 0) {
            for (int i = 0; i < rc; i++) {
                PCRE2_SIZE start = ovector[2*i];
                PCRE2_SIZE end = ovector[2*i+1];
                
                if (start != PCRE2_UNSET && end != PCRE2_UNSET) {
                    size_t len = end - start;
                    char* word = malloc(len + 1);
                    if (word) {
                        memcpy(word, code + start, len);
                        word[len] = '\0';
                        add_node(results, "regex_node", word);
                        free(word);
                    }
                }
            }
        }
        
        start_offset = ovector[1];
    }
    
    pcre2_match_data_free(match_data);
    pcre2_code_free(re);
    
    return results;
}

// Tree-sitter based parsing function
static ParseResults* parse_with_treesitter(const char* code, const char* language_name) {
    ParseResults* results = init_parse_results();
    
    // Get the appropriate language parser
    const TSLanguage* language = get_language(language_name);
    if (!language) {
        // Fall back to basic parsing when no language parser is available
        free_parse_results(results);
        return fallback_parse(code, language_name);
    }

    // Create parser
    TSParser* parser = ts_parser_new();
    ts_parser_set_language(parser, language);

    // Enable logging for tree-sitter parser
    TSLogger logger = {
        .payload = NULL,
        .log = treesitter_log_callback
    };
    // ts_parser_set_logger(parser, logger);

    // Set a timeout to prevent infinite loops (10 seconds)
    ts_parser_set_timeout_micros(parser, 10000000); // 10 seconds in microseconds
    
    // Parse the code
    TSTree* tree = ts_parser_parse_string(parser, NULL, code, strlen(code));
    
    // Check if parsing failed or timed out
    if (!tree) {
        // Fall back to basic parsing when tree-sitter fails
        free_parse_results(results);
        ts_parser_delete(parser);
        return fallback_parse(code, language_name);
    }
    
    TSNode root_node = ts_tree_root_node(tree);
    
    // Check if the root node is null (parsing failed)
    if (ts_node_is_null(root_node)) {
        free_parse_results(results);
        ts_tree_delete(tree);
        ts_parser_delete(parser);
        return fallback_parse(code, language_name);
    }
    
    // Traverse the tree and collect nodes
    traverse_tree(root_node, code, results, language_name);

    // Clean up
    ts_tree_delete(tree);
    ts_parser_delete(parser);
    
    return results;
}

// Helper to check if a name is in a function names list
static int is_function_name(const char* name, char** function_names, size_t function_count) {
    for (size_t i = 0; i < function_count; i++) {
        if (strcmp(function_names[i], name) == 0) {
            return 1;
        }
    }
    return 0;
}

// Helper to extract just the method name from qualified calls
static char* extract_method_name(const char* qualified_name) {
    const char* last_dot = strrchr(qualified_name, '.');
    if (last_dot) {
        char* result = strdup(last_dot + 1);
        if (result == NULL) {
            // Handle allocation failure
            return NULL;
        }
        return result;
    } else {
        char* result = strdup(qualified_name);
        if (result == NULL) {
            // Handle allocation failure
            return NULL;
        }
        return result;
    }
}

// Helper function to check if a function name is a C++ operator
static int is_operator_function(const char* func_name) {
    if (!func_name) return 0;

    // List of common C++ operators
    const char* operators[] = {
        "operator()", "operator[]", "operator->", "operator++", "operator--",
        "operator+", "operator-", "operator*", "operator/", "operator%",
        "operator+=", "operator-=", "operator*=", "operator/=", "operator%=",
        "operator==", "operator!=", "operator<", "operator>", "operator<=", "operator>=",
        "operator&&", "operator||", "operator!", "operator&", "operator|", "operator^",
        "operator&=", "operator|=", "operator^=", "operator~", "operator<<", "operator>>",
        "operator<<=", "operator>>=", "operator=", "operator new", "operator delete",
        "operator new[]", "operator delete[]", "operator->*", "operator,", "operator co_await"
    };

    const size_t num_operators = sizeof(operators) / sizeof(operators[0]);

    for (size_t i = 0; i < num_operators; i++) {
        if (strcmp(func_name, operators[i]) == 0) {
            return 1;
        }
    }

    return 0;
}

// Smart BM25 tokenization using tree-sitter AST
static TokenResults* extract_bm25_tokens_treesitter(const char* code, const char* language) {
    TokenResults* tokens = init_token_results();
    
    // Parse the code using tree-sitter to get comprehensive AST nodes
    ParseResults* ast_nodes = parse_with_treesitter(code, language);
    
    for (size_t i = 0; i < ast_nodes->count; i++) {
        const char* node_type = ast_nodes->node_types[i];
        const char* node_text = ast_nodes->node_texts[i];
        
        // Function definitions - always include with prefix
        if (strcmp(node_type, "function_definition") == 0) {
            char prefixed_token[256];
            snprintf(prefixed_token, sizeof(prefixed_token), "[FUNCDEF]%s", node_text);
            add_token(tokens, prefixed_token);
            continue;
        }
        
        // Class definitions - always include with prefix
        if (strcmp(node_type, "class_definition") == 0) {
            char prefixed_token[256];
            snprintf(prefixed_token, sizeof(prefixed_token), "[CLASS]%s", node_text);
            add_token(tokens, prefixed_token);
            continue;
        }
        
        // Function calls - include with prefix, but skip if it's a function/class we already defined
        if (strcmp(node_type, "call") == 0) {
            char prefixed_token[256];
            snprintf(prefixed_token, sizeof(prefixed_token), "[CALL]%s", node_text);
            add_token(tokens, prefixed_token);
            continue;
        }

        
        if (strcmp(node_type, "regex_node") == 0) {
            char prefixed_token[256];
            snprintf(prefixed_token, sizeof(prefixed_token), "%s", node_text);
            add_token(tokens, prefixed_token);
            continue;
        }

        if (strcmp(node_type, "identifier") == 0) {
            char prefixed_token[256];
            snprintf(prefixed_token, sizeof(prefixed_token), "[IDENTIFIER]%s", node_text);
            add_token(tokens, prefixed_token);
            continue;
        }

        if (strcmp(node_type, "var_declaration") == 0) {
            char prefixed_token[256];
            snprintf(prefixed_token, sizeof(prefixed_token), "[VARDECL]%s", node_text);
            add_token(tokens, prefixed_token);
            continue;
        }

        if (strcmp(node_type, "func_declaration") == 0) {
            char prefixed_token[256];
            snprintf(prefixed_token, sizeof(prefixed_token), "[FUNCDECL]%s", node_text);
            add_token(tokens, prefixed_token);
            continue;
        }

        if (strcmp(node_type, "object_creation") == 0) {
            char prefixed_token[256];
            snprintf(prefixed_token, sizeof(prefixed_token), "[OBJECTCREATION]%s", node_text);
            add_token(tokens, prefixed_token);
            continue;
        }
    }
    

    free_parse_results(ast_nodes);
    return tokens;
}

// Main parsing function - exposed to Python
static PyObject* parse_code_with_treesitter(PyObject* self, PyObject* args) {
    const char* code;
    const char* language_name = NULL;
    
    if (!PyArg_ParseTuple(args, "s|z", &code, &language_name)) {
        return NULL;
    }
    
    if (!language_name) {
        printf("ERROR: Language name is required for parsing\n");
        exit(1);
    }
    
    // Parse the code using tree-sitter
    ParseResults* results = parse_with_treesitter(code, language_name);
    
    // Convert results to Python list of tuples
    PyObject* py_results = PyList_New(results->count);
    for (size_t i = 0; i < results->count; i++) {
        PyObject* tuple = PyTuple_New(2);
        PyTuple_SetItem(tuple, 0, PyUnicode_FromString(results->node_types[i]));
        PyTuple_SetItem(tuple, 1, PyUnicode_FromString(results->node_texts[i]));
        PyList_SetItem(py_results, i, tuple);
    }
    
    // Cleanup
    free_parse_results(results);
    
    return py_results;
}

// BM25 tokenization function - exposed to Python
static PyObject* tokenize_for_bm25(PyObject* self, PyObject* args) {
    const char* code;
    const char* language_name = NULL;
    
    if (!PyArg_ParseTuple(args, "s|z", &code, &language_name)) {
        return NULL;
    }
    if (!language_name) {
        printf("ERROR: Language name is required for BM25 tokenization\n");
        exit(1);
    }
    
    // Extract BM25 tokens using tree-sitter
    TokenResults* results = extract_bm25_tokens_treesitter(code, language_name);
    // Convert results to Python list
    PyObject* py_results = PyList_New(results->count);
    for (size_t i = 0; i < results->count; i++) {
        PyList_SetItem(py_results, i, PyUnicode_FromString(results->tokens[i]));
    }
    
    // Cleanup
    free_token_results(results);
    
    return py_results;
}

// Method definition table
// Function to enable/disable debug mode
static PyObject* set_debug_mode(PyObject* self, PyObject* args) {
    int enabled;
    if (!PyArg_ParseTuple(args, "i", &enabled)) {
        return NULL;
    }
    debug_enabled = enabled;
    Py_RETURN_NONE;
}

// Function to get current debug mode
static PyObject* get_debug_mode(PyObject* self, PyObject* args) {
    return PyLong_FromLong(debug_enabled);
}

// Python wrapper for fallback_parse function
static PyObject* fallback_parse_py(PyObject* self, PyObject* args) {
    const char* code;
    const char* language;
    
    if (!PyArg_ParseTuple(args, "ss", &code, &language)) {
        return NULL;
    }
    
    // Call the C fallback_parse function
    ParseResults* results = fallback_parse(code, language);
    if (!results) {
        PyErr_SetString(PyExc_RuntimeError, "Failed to parse code");
        return NULL;
    }
    
    // Convert results to Python list of dictionaries
    PyObject* py_results = PyList_New(0);
    if (!py_results) {
        free_parse_results(results);
        return NULL;
    }
    
    for (size_t i = 0; i < results->count; i++) {
        PyObject* node_dict = PyDict_New();
        if (!node_dict) {
            Py_DECREF(py_results);
            free_parse_results(results);
            return NULL;
        }
        
        // Add type and name to dictionary
        PyObject* type_str = PyUnicode_FromString(results->node_types[i]);
        PyObject* name_str = PyUnicode_FromString(results->node_texts[i]);
        
        if (!type_str || !name_str) {
            Py_XDECREF(type_str);
            Py_XDECREF(name_str);
            Py_DECREF(node_dict);
            Py_DECREF(py_results);
            free_parse_results(results);
            return NULL;
        }
        
        PyDict_SetItemString(node_dict, "type", type_str);
        PyDict_SetItemString(node_dict, "name", name_str);
        
        Py_DECREF(type_str);
        Py_DECREF(name_str);
        
        // Add node to results list
        if (PyList_Append(py_results, node_dict) != 0) {
            Py_DECREF(node_dict);
            Py_DECREF(py_results);
            free_parse_results(results);
            return NULL;
        }
        
        Py_DECREF(node_dict);
    }
    
    free_parse_results(results);
    return py_results;
}

static PyMethodDef TreeSitterMethods[] = {
    {"parse_code_with_treesitter", parse_code_with_treesitter, METH_VARARGS, 
     "Parse code and return AST nodes as (type, text) tuples"},
    {"tokenize_for_bm25", tokenize_for_bm25, METH_VARARGS,
     "Tokenize code for BM25 search with prefixes"},
    {"fallback_parse", fallback_parse_py, METH_VARARGS,
     "Fallback parser equivalent to re.findall(r'\\b\\w+\\b', text)"},
    {"set_debug_mode", set_debug_mode, METH_VARARGS,
     "Enable or disable debug mode (1=enabled, 0=disabled)"},
    {"get_debug_mode", get_debug_mode, METH_NOARGS,
     "Get current debug mode status"},
    {NULL, NULL, 0, NULL}
};

// Module definition
static struct PyModuleDef treesittermodule = {
    PyModuleDef_HEAD_INIT,
    "treesitter_parse",  // Module name
    "Enhanced code parser with BM25 tokenization",  // Module description
    -1,  // Module keeps state in global variables
    TreeSitterMethods
};

// Module initialization
PyMODINIT_FUNC PyInit_treesitter_parse(void) {
    return PyModule_Create(&treesittermodule);
}