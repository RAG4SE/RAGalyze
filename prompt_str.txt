<START_OF_SYS_PROMPT>

You are a code assistant which answers user questions on a Github Repo or a local repo.
You will receive user query, relevant context, and past conversation history.

LANGUAGE DETECTION AND RESPONSE:
- Detect the language of the user's query
- Respond in the SAME language as the user's query
- IMPORTANT:If a specific language is requested in the prompt, prioritize that language over the query language

FORMAT YOUR RESPONSE USING MARKDOWN:
- Use proper markdown syntax for all formatting
- For code blocks, use triple backticks with language specification (```python, ```javascript, etc.)
- Use ## headings for major sections
- Use bullet points or numbered lists where appropriate
- Format tables using markdown table syntax when presenting structured data
- Use **bold** and *italic* for emphasis
- When referencing file paths, use `inline code` formatting

IMPORTANT FORMATTING RULES:
1. DO NOT include ```markdown fences at the beginning or end of your answer
2. Start your response directly with the content
3. The content will already be rendered as markdown, so just provide the raw markdown content

Think step by step and ensure your answer is well-structured and visually organized.


Please provide a comprehensive answer to the user's question based on the provided context.

IMPORTANT FORMATTING RULES:
1. Respond in the same language as the user's question
2. Format your response using markdown for better readability
3. Use code blocks, bullet points, headings, and other markdown features as appropriate
4. Be clear, concise, and helpful
5. If you use code examples, make sure they are properly formatted with language-specific syntax highlighting
6. Structure your answer logically with clear sections if the question is complex
<END_OF_SYS_PROMPT>
<START_OF_CONTEXT>
1.
File Path: libyul/backends/evm/EVMCodeTransform.cpp
Code Snippet:
```
 varName, true))
188: 					m_assembly.appendInstruction(evmasm::swapInstruction(static_cast<unsigned>(heightDiff - 1)));
189: 				m_assembly.appendInstruction(evmasm::Instruction::POP);
190: 				break;
191: 			}
192: 			if (!foundUnusedSlot)
193: 				atTopOfStack = false;
194: 		}
195: 	}
196: }
197: 
198: void CodeTransform::stackError(StackTooDeepError _error, int _targetStackHeight)
199: {
200: 	m_assembly.appendInstruction(evmasm::Instruction::INVALID);
201: 	// Correct the stack.
202: 	while (m_assembly.stackHeight() > _targetStackHeight)
203: 		m_assembly.appendInstruction(evmasm::Instruction::POP);
204: 	while (m_assembly.stackHeight() < _targetStackHeight)
205: 		m_assembly.appendConstant(u256(0));
206: 	// Store error.
207: 	m_stackErrors.emplace_back(std::move(_error));
208: 	m_assembly.markAsInvalid();
209: }
210: 
211: void CodeTransform::operator()(Assignment const& _assignment)
212: {
213: 	int height = m_assembly.stackHeight();
214: 	std::visit(*this, *_assignment.value);
215: 	expectDeposit(static_cast<int>(_assignment.variableNames.size()), height);
216: 
217: 	m_assembly.setSourceLocation(originLocationOf(_assignment));
218: 	generateMultiAssignment(_assignment.variableNames);
219: }
220: 
221: void CodeTransform::operator()(ExpressionStatement const& _statement)
222: {
223: 	m_assembly.setSourceLocation(originLocationOf(_statement));
224: 	std::visit(*this, _statement.expression);
225: }
226: 
227: void CodeTransform::operator()(FunctionCall const& _call)
228: {
229: 	yulAssert(m_scope, "");
230: 
231: 	m_assembly.setSourceLocation(originLocationOf(_call));
232: 	if (std::optional<BuiltinHandle> builtinHandle = m_dialect.findBuiltin(_call.functionName.name.str()))
233: 	{
234: 		BuiltinFunctionForEVM const& builtin = m_dialect.builtin(*builtinHandle);
235: 		for (auto&& [i, arg]: _call.arguments | ranges::views::enumerate | ranges::views::reverse)
236: 			if (!builtin.literalArgument(i))
237: 				visitExpression(arg);
238: 		m_assembly.setSourceLocation(originLocationOf(_call));
239: 		builtin.generateCode(_call, m_assembly, m_builtinContext);
240: 	}
241: 	else
242: 	{
243: 		AbstractAssembly::LabelID returnLabel = m_assembly.newLabelId();
244: 		m_assembly.appendLabelReference(returnLabel);
245: 
246: 		Scope::Function* function = nullptr;
247: 		yulAssert(m_scope->lookup(_call.functionName.name, GenericVisitor{
248: 			[](Scope::Variable&) { yulAssert(false, "Expected function name."); },
249: 			[&](Scope::Function& _function) { function = &_function; }
250: 		}), "Function name not found.");
251: 		yulAssert(function, "");
252: 		yulAssert(function->numArguments == _call.arguments.size(), "");
253: 		for (auto const& arg: _call.arguments | ranges::views::reverse)
254: 			visitExpression(arg);
255: 		m_assembly.setSourceLocation(originLocationOf(_call));

```
2.
File Path: libyul/backends/evm/EVMCodeTransform.cpp
Code Snippet:
```
256: 		m_assembly.appendJumpTo(
257: 			functionEntryID(*function),
258: 			static_cast<int>(function->numReturns) - static_cast<int>(function->numArguments) - 1,
259: 			AbstractAssembly::JumpType::IntoFunction
260: 		);
261: 		m_assembly.appendLabel(returnLabel);
262: 	}
263: }
264: 
265: void CodeTransform::operator()(Identifier const& _identifier)
266: {
267: 	m_assembly.setSourceLocation(originLocationOf(_identifier));
268: 	// First search internals, then externals.
269: 	yulAssert(m_scope, "");
270: 	if (m_scope->lookup(_identifier.name, GenericVisitor{
271: 		[&](Scope::Variable& _var)
272: 		{
273: 			// TODO: opportunity for optimization: Do not DUP if this is the last reference
274: 			// to the top most element of the stack
275: 			if (size_t heightDiff = variableHeightDiff(_var, _identifier.name, false))
276: 				m_assembly.appendInstruction(evmasm::dupInstruction(static_cast<unsigned>(heightDiff)));
277: 			else
278: 				// Store something to balance the stack
279: 				m_assembly.appendConstant(u256(0));
280: 			decreaseReference(_identifier.name, _var);
281: 		},
282: 		[](Scope::Function&)
283: 		{
284: 			yulAssert(false, "Function not removed during desugaring.");
285: 		}
286: 	}))
287: 	{
288: 		return;
289: 	}
290: 	yulAssert(
291: 		m_identifierAccessCodeGen,
292: 		"Identifier not found and no external access available."
293: 	);
294: 	m_identifierAccessCodeGen(_identifier, IdentifierContext::RValue, m_assembly);
295: }
296: 
297: void CodeTransform::operator()(Literal const& _literal)
298: {
299: 	m_assembly.setSourceLocation(originLocationOf(_literal));
300: 	m_assembly.appendConstant(_literal.value.value());
301: }
302: 
303: void CodeTransform::operator()(If const& _if)
304: {
305: 	visitExpression(*_if.condition);
306: 	m_assembly.setSourceLocation(originLocationOf(_if));
307: 	m_assembly.appendInstruction(evmasm::Instruction::ISZERO);
308: 	AbstractAssembly::LabelID end = m_assembly.newLabelId();
309: 	m_assembly.appendJumpToIf(end);
310: 	(*this)(_if.body);
311: 	m_assembly.setSourceLocation(originLocationOf(_if));
312: 	m_assembly.appendLabel(end);
313: }
314: 
315: void CodeTransform::operator()(Switch const& _switch)
316: {
317: 	visitExpression(*_switch.expression);
318: 	int expressionHeight = m_assembly.stackHeight();
319: 	std::map<Case const*, AbstractAssembly::LabelID> caseBodies;
320: 	AbstractAssembly::LabelID end = m_assembly.newLabelId();
321: 	for (Case const& c: _switch.cases)
322: 	{
323: 		if (c.value)
324: 		{
325: 			(*this)(*c.value);
326: 			m_assembly.setSourceLocation(originLocationOf(c));
327: 			AbstractAssembly::LabelID bodyLabel = m_assembly.newLabelId();
328: 			caseBodies[&c] = bodyLabel;

```
3.
File Path: libyul/backends/evm/EVMCodeTransform.cpp
Code Snippet:
```
);
514: 
515: 	int const stackHeightBody = m_assembly.stackHeight();
516: 	m_context->forLoopStack.emplace(Context::ForLoopLabels{ {postPart, stackHeightBody}, {loopEnd, stackHeightBody} });
517: 	(*this)(_forLoop.body);
518: 
519: 	m_assembly.setSourceLocation(originLocationOf(_forLoop));
520: 	m_assembly.appendLabel(postPart);
521: 
522: 	(*this)(_forLoop.post);
523: 
524: 	m_assembly.setSourceLocation(originLocationOf(_forLoop));
525: 	m_assembly.appendJumpTo(loopStart);
526: 	m_assembly.appendLabel(loopEnd);
527: 
528: 	finalizeBlock(_forLoop.pre, stackStartHeight);
529: 	m_context->forLoopStack.pop();
530: 	m_scope = originalScope;
531: }
532: 
533: int CodeTransform::appendPopUntil(int _targetDepth)
534: {
535: 	int const stackDiffAfter = m_assembly.stackHeight() - _targetDepth;
536: 	for (int i = 0; i < stackDiffAfter; ++i)
537: 		m_assembly.appendInstruction(evmasm::Instruction::POP);
538: 	return stackDiffAfter;
539: }
540: 
541: void CodeTransform::operator()(Break const& _break)
542: {
543: 	yulAssert(!m_context->forLoopStack.empty(), "Invalid break-statement. Requires surrounding for-loop in code generation.");
544: 	m_assembly.setSourceLocation(originLocationOf(_break));
545: 
546: 	Context::JumpInfo const& jump = m_context->forLoopStack.top().done;
547: 	m_assembly.appendJumpTo(jump.label, appendPopUntil(jump.targetStackHeight));
548: }
549: 
550: void CodeTransform::operator()(Continue const& _continue)
551: {
552: 	yulAssert(!m_context->forLoopStack.empty(), "Invalid continue-statement. Requires surrounding for-loop in code generation.");
553: 	m_assembly.setSourceLocation(originLocationOf(_continue));
554: 
555: 	Context::JumpInfo const& jump = m_context->forLoopStack.top().post;
556: 	m_assembly.appendJumpTo(jump.label, appendPopUntil(jump.targetStackHeight));
557: }
558: 
559: void CodeTransform::operator()(Leave const& _leaveStatement)
560: {
561: 	yulAssert(m_functionExitLabel, "Invalid leave-statement. Requires surrounding function in code generation.");
562: 	yulAssert(m_functionExitStackHeight, "");
563: 	m_assembly.setSourceLocation(originLocationOf(_leaveStatement));
564: 	m_assembly.appendJumpTo(*m_functionExitLabel, appendPopUntil(*m_functionExitStackHeight));
565: }
566: 
567: void CodeTransform::operator()(Block const& _block)
568: {
569: 	Scope* originalScope = m_scope;
570: 	m_scope = m_info.scopes.at(&_block).get();
571: 
572: 	for (auto const& statement: _block.statements)
573: 		if (auto function = std::get_if<FunctionDefinition>(&statement))
574: 			createFunctionEntryID(*function);
575: 
576: 	int blockStartStackHeight = m_assembly.stackHeight();
577: 	visitStatements(_block.statements);
578: 
579: 	bool isOutermostFunctionBodyBlock = m_scope && m_scope->superScope && m_scope->superScope->functionScope;
580: 	bool performValidation = !
```
4.
File Path: libyul/optimiser/DataFlowAnalyzer.cpp
Code Snippet:
```
FlowAnalyzer.h>
23: 
24: #include <libyul/optimiser/NameCollector.h>
25: #include <libyul/optimiser/Semantics.h>
26: #include <libyul/optimiser/OptimizerUtilities.h>
27: #include <libyul/optimiser/KnowledgeBase.h>
28: #include <libyul/AST.h>
29: #include <libyul/Dialect.h>
30: #include <libyul/Exceptions.h>
31: #include <libyul/Utilities.h>
32: 
33: #include <libsolutil/CommonData.h>
34: #include <libsolutil/cxx20.h>
35: 
36: #include <variant>
37: 
38: #include <range/v3/view/reverse.hpp>
39: 
40: using namespace solidity;
41: using namespace solidity::util;
42: using namespace solidity::yul;
43: 
44: DataFlowAnalyzer::DataFlowAnalyzer(
45: 	Dialect const& _dialect,
46: 	MemoryAndStorage _analyzeStores,
47: 	std::map<YulName, SideEffects> _functionSideEffects
48: ):
49: 	m_dialect(_dialect),
50: 	m_functionSideEffects(std::move(_functionSideEffects)),
51: 	m_knowledgeBase([this](YulName _var) { return variableValue(_var); }),
52: 	m_analyzeStores(_analyzeStores == MemoryAndStorage::Analyze)
53: {
54: 	if (m_analyzeStores)
55: 	{
56: 		if (auto const& builtinHandle = _dialect.memoryStoreFunctionHandle())
57: 			m_storeFunctionName[static_cast<unsigned>(StoreLoadLocation::Memory)] = YulName{_dialect.builtin(*builtinHandle).name};
58: 		if (auto const& builtinHandle = _dialect.memoryLoadFunctionHandle())
59: 			m_loadFunctionName[static_cast<unsigned>(StoreLoadLocation::Memory)] = YulName{_dialect.builtin(*builtinHandle).name};
60: 		if (auto const& builtinHandle = _dialect.storageStoreFunctionHandle())
61: 			m_storeFunctionName[static_cast<unsigned>(StoreLoadLocation::Storage)] = YulName{_dialect.builtin(*builtinHandle).name};
62: 		if (auto const& builtinHandle = _dialect.storageLoadFunctionHandle())
63: 			m_loadFunctionName[static_cast<unsigned>(StoreLoadLocation::Storage)] = YulName{_dialect.builtin(*builtinHandle).name};
64: 	}
65: }
66: 
67: void DataFlowAnalyzer::operator()(ExpressionStatement& _statement)
68: {
69: 	if (m_analyzeStores)
70: 	{
71: 		if (auto vars = isSimpleStore(StoreLoadLocation::Storage, _statement))
72: 		{
73: 			ASTModifier::operator()(_statement);
74: 			cxx20::erase_if(m_state.environment.storage, mapTuple([&](auto&& key, auto&& value) {
75: 				return
76: 					!m_knowledgeBase.knownToBeDifferent(vars->first, key) &&
77: 					vars->second != value;
78: 			}));
79: 			m_state.environment.storage[vars->first] = vars->second;
80: 			return;
81: 		}
82: 		else if (auto vars = isSimpleStore(StoreLoadLocation::Memory, _statement))
83: 		{
84: 			ASTModifier::operator()(_statement);
85:
```
5.
File Path: libyul/optimiser/StackToMemoryMover.cpp
Code Snippet:
```
MDialect.h>
20: 
21: #include <libyul/AST.h>
22: #include <libyul/Utilities.h>
23: 
24: #include <libsolutil/CommonData.h>
25: 
26: #include <range/v3/algorithm/none_of.hpp>
27: #include <range/v3/view/filter.hpp>
28: #include <range/v3/view/transform.hpp>
29: #include <range/v3/view/zip.hpp>
30: #include <range/v3/range/conversion.hpp>
31: 
32: using namespace solidity;
33: using namespace solidity::yul;
34: 
35: namespace
36: {
37: std::vector<Statement> generateMemoryStore(
38: 	Dialect const& _dialect,
39: 	langutil::DebugData::ConstPtr const& _debugData,
40: 	LiteralValue const& _mpos,
41: 	Expression _value
42: )
43: {
44: 	std::optional<BuiltinHandle> memoryStoreFunctionHandle = _dialect.memoryStoreFunctionHandle();
45: 	yulAssert(memoryStoreFunctionHandle);
46: 	std::vector<Statement> result;
47: 	result.emplace_back(ExpressionStatement{_debugData, FunctionCall{
48: 		_debugData,
49: 		Identifier{_debugData, YulName{_dialect.builtin(*memoryStoreFunctionHandle).name}},
50: 		{
51: 			Literal{_debugData, LiteralKind::Number, _mpos},
52: 			std::move(_value)
53: 		}
54: 	}});
55: 	return result;
56: }
57: 
58: FunctionCall generateMemoryLoad(Dialect const& _dialect, langutil::DebugData::ConstPtr const& _debugData, LiteralValue const& _mpos)
59: {
60: 	std::optional<BuiltinHandle> const& memoryLoadHandle = _dialect.memoryLoadFunctionHandle();
61: 	yulAssert(memoryLoadHandle);
62: 	return FunctionCall{
63: 		_debugData,
64: 		Identifier{_debugData, YulName{_dialect.builtin(*memoryLoadHandle).name}}, {
65: 			Literal{
66: 				_debugData,
67: 				LiteralKind::Number,
68: 				_mpos
69: 			}
70: 		}
71: 	};
72: }
73: }
74: 
75: void StackToMemoryMover::run(
76: 	OptimiserStepContext& _context,
77: 	u256 _reservedMemory,
78: 	std::map<YulName, uint64_t> const& _memorySlots,
79: 	uint64_t _numRequiredSlots,
80: 	Block& _block
81: )
82: {
83: 	VariableMemoryOffsetTracker memoryOffsetTracker(_reservedMemory, _memorySlots, _numRequiredSlots);
84: 	StackToMemoryMover stackToMemoryMover(
85: 		_context,
86: 		memoryOffsetTracker,
87: 		util::applyMap(
88: 			allFunctionDefinitions(_block),
89: 			util::mapTuple([](YulName _name, FunctionDefinition const* _funDef) {
90: 				return make_pair(_name, _funDef->returnVariables);
91: 			}),
92: 			std::map<YulName, NameWithDebugDataList>{}
93: 		)
94: 	);
95: 	stackToMemoryMover(_block);
96: 	_block.statements += std::move(stack
```
6.
File Path: libyul/AsmAnalysis.cpp
Code Snippet:
```
() || hasVariable, "");
652: }
653: 
654: Scope& AsmAnalyzer::scope(Block const* _block)
655: {
656: 	yulAssert(m_info.scopes.count(_block) == 1, "Scope requested but not present.");
657: 	auto scopePtr = m_info.scopes.at(_block);
658: 	yulAssert(scopePtr, "Scope requested but not present.");
659: 	return *scopePtr;
660: }
661: 
662: void AsmAnalyzer::expectValidIdentifier(YulName _identifier, SourceLocation const& _location)
663: {
664: 	// NOTE: the leading dot case is handled by the parser not allowing it.
665: 	if (boost::ends_with(_identifier.str(), "."))
666: 		m_errorReporter.syntaxError(
667: 			3384_error,
668: 			_location,
669: 			"\"" + _identifier.str() + "\" is not a valid identifier (ends with a dot)."
670: 		);
671: 
672: 	if (_identifier.str().find("..") != std::string::npos)
673: 		m_errorReporter.syntaxError(
674: 			7771_error,
675: 			_location,
676: 			"\"" + _identifier.str() + "\" is not a valid identifier (contains consecutive dots)."
677: 		);
678: 
679: 	if (m_dialect.reservedIdentifier(_identifier.str()))
680: 		m_errorReporter.declarationError(
681: 			5017_error,
682: 			_location,
683: 			"The identifier \"" + _identifier.str() + "\" is reserved and can not be used."
684: 		);
685: }
686: 
687: bool AsmAnalyzer::validateInstructions(std::string const& _instructionIdentifier, langutil::SourceLocation const& _location)
688: {
689: 	// NOTE: This function uses the default EVM version instead of the currently selected one.
690: 	auto const& defaultEVMDialect = EVMDialect::strictAssemblyForEVM(EVMVersion{}, std::nullopt);
691: 	auto const builtinHandle = defaultEVMDialect.findBuiltin(_instructionIdentifier);
692: 	if (builtinHandle && defaultEVMDialect.builtin(*builtinHandle).instruction.has_value())
693: 		return validateInstructions(*defaultEVMDialect.builtin(*builtinHandle).instruction, _location);
694: 
695: 	// TODO: Change `prague()` to `EVMVersion{}` once EOF gets deployed
696: 	auto const& eofDialect = EVMDialect::strictAssemblyForEVM(EVMVersion::prague(), 1);
697: 	auto const eofBuiltinHandle = eofDialect.findBuiltin(_instructionIdentifier);
698: 	if (eofBuiltinHandle && eofDialect.builtin(*eofBuiltinHandle).instruction.has_value())
699: 		return validateInstructions(*eofDialect.builtin(*eofBuiltinHandle).instruction, _location);
700: 
701: 	return false;
702: }
703: 
704: bool AsmAnalyzer::validateInstructions(evmasm::Instruction _instr, SourceLocation const& _location)
705: {
706: 	// We assume that returndatacopy, returndatasize and staticcall are either all available
707: 	// or all not available.
708: 	yulAssert(m_evmVersion.supportsReturndata() == m_evmVersion.hasStaticCall(), "");
709: 	// Similarly we assume bitwise shifting and create2 go together.
710: 	yulAssert(m_evmVersion.hasBitwiseShifting()
```
7.
File Path: libyul/AsmAnalysis.cpp
Code Snippet:
```
_location,
676: 			"\"" + _identifier.str() + "\" is not a valid identifier (contains consecutive dots)."
677: 		);
678: 
679: 	if (m_dialect.reservedIdentifier(_identifier.str()))
680: 		m_errorReporter.declarationError(
681: 			5017_error,
682: 			_location,
683: 			"The identifier \"" + _identifier.str() + "\" is reserved and can not be used."
684: 		);
685: }
686: 
687: bool AsmAnalyzer::validateInstructions(std::string const& _instructionIdentifier, langutil::SourceLocation const& _location)
688: {
689: 	// NOTE: This function uses the default EVM version instead of the currently selected one.
690: 	auto const& defaultEVMDialect = EVMDialect::strictAssemblyForEVM(EVMVersion{}, std::nullopt);
691: 	auto const builtinHandle = defaultEVMDialect.findBuiltin(_instructionIdentifier);
692: 	if (builtinHandle && defaultEVMDialect.builtin(*builtinHandle).instruction.has_value())
693: 		return validateInstructions(*defaultEVMDialect.builtin(*builtinHandle).instruction, _location);
694: 
695: 	// TODO: Change `prague()` to `EVMVersion{}` once EOF gets deployed
696: 	auto const& eofDialect = EVMDialect::strictAssemblyForEVM(EVMVersion::prague(), 1);
697: 	auto const eofBuiltinHandle = eofDialect.findBuiltin(_instructionIdentifier);
698: 	if (eofBuiltinHandle && eofDialect.builtin(*eofBuiltinHandle).instruction.has_value())
699: 		return validateInstructions(*eofDialect.builtin(*eofBuiltinHandle).instruction, _location);
700: 
701: 	return false;
702: }
703: 
704: bool AsmAnalyzer::validateInstructions(evmasm::Instruction _instr, SourceLocation const& _location)
705: {
706: 	// We assume that returndatacopy, returndatasize and staticcall are either all available
707: 	// or all not available.
708: 	yulAssert(m_evmVersion.supportsReturndata() == m_evmVersion.hasStaticCall(), "");
709: 	// Similarly we assume bitwise shifting and create2 go together.
710: 	yulAssert(m_evmVersion.hasBitwiseShifting() == m_evmVersion.hasCreate2(), "");
711: 
712: 	// These instructions are disabled in the dialect.
713: 	yulAssert(
714: 		_instr != evmasm::Instruction::JUMP &&
715: 		_instr != evmasm::Instruction::JUMPI &&
716: 		_instr != evmasm::Instruction::JUMPDEST,
717: 	"");
718: 
719: 	auto errorForVM = [&](ErrorId _errorId, std::string const& vmKindMessage) {
720: 		m_errorReporter.typeError(
721: 			_errorId,
722: 			_location,
723: 			fmt::format(
724: 				"The \"{instruction}\" instruction is {kind} VMs (you are currently compiling for \"{version}\").",
725: 				fmt::arg("instruction", boost::to_lower_copy(instructionInfo(_instr, m_evmVersion).name)),
726: 				fmt::arg("kind", vmKindMessage),
727: 				fmt::arg("version", m_evmVersion.name())
728: 			)
729: 		);
730: 	};
731: 
732: 	// The errors below are meant to be issued when processing
```
8.
File Path: libyul/backends/evm/ConstantOptimiser.cpp
Code Snippet:
```
, findRepresentation(u256(abs(lowerPart))));
170: 
171: 		if (m_maxSteps > 0)
172: 			m_maxSteps--;
173: 		routine = min(std::move(routine), std::move(newRoutine));
174: 	}
175: 	yulAssert(MiniEVMInterpreter{m_dialect}.eval(*routine.expression) == _value, "Invalid expression generated.");
176: 	return m_cache[_value] = std::move(routine);
177: }
178: 
179: Representation RepresentationFinder::represent(u256 const& _value) const
180: {
181: 	Representation repr;
182: 	repr.expression = std::make_unique<Expression>(Literal{m_debugData, LiteralKind::Number, LiteralValue{_value, formatNumber(_value)}});
183: 	repr.cost = m_meter.costs(*repr.expression);
184: 	return repr;
185: }
186: 
187: Representation RepresentationFinder::represent(
188: 	YulName _instruction,
189: 	Representation const& _argument
190: ) const
191: {
192: 	Representation repr;
193: 	repr.expression = std::make_unique<Expression>(FunctionCall{
194: 		m_debugData,
195: 		Identifier{m_debugData, _instruction},
196: 		{ASTCopier{}.translate(*_argument.expression)}
197: 	});
198: 	repr.cost = _argument.cost + m_meter.instructionCosts(
199: 		*m_dialect.builtin(*m_dialect.findBuiltin(_instruction.str())).instruction
200: 	);
201: 	return repr;
202: }
203: 
204: Representation RepresentationFinder::represent(
205: 	YulName _instruction,
206: 	Representation const& _arg1,
207: 	Representation const& _arg2
208: ) const
209: {
210: 	Representation repr;
211: 	repr.expression = std::make_unique<Expression>(FunctionCall{
212: 		m_debugData,
213: 		Identifier{m_debugData, _instruction},
214: 		{ASTCopier{}.translate(*_arg1.expression), ASTCopier{}.translate(*_arg2.expression)}
215: 	});
216: 	repr.cost = m_meter.instructionCosts(
217: 		*m_dialect.builtin(*m_dialect.findBuiltin(_instruction.str())).instruction) + _arg1.cost + _arg2.cost;
218: 	return repr;
219: }
220: 
221: Representation RepresentationFinder::min(Representation _a, Representation _b)
222: {
223: 	if (_a.cost <= _b.cost)
224: 		return _a;
225: 	else
226: 		return _b;
227: }
```
9.
File Path: libyul/optimiser/ControlFlowSimplifier.cpp
Code Snippet:
```
NoCaseSwitch(_switchStmt);
156: 			else if (_switchStmt.cases.size() == 1)
157: 				return reduceSingleCaseSwitch(_switchStmt);
158: 
159: 			return {};
160: 		}
161: 	};
162: 	iterateReplacing(
163: 		_statements,
164: 		[&](Statement& _stmt) -> OptionalStatements
165: 		{
166: 			OptionalStatements result = std::visit(visitor, _stmt);
167: 			if (result)
168: 				simplify(*result);
169: 			else
170: 				visit(_stmt);
171: 			return result;
172: 		}
173: 	);
174: }
175: 
176: OptionalStatements ControlFlowSimplifier::reduceNoCaseSwitch(Switch& _switchStmt) const
177: {
178: 	yulAssert(_switchStmt.cases.empty(), "Expected no case!");
179: 	std::optional<BuiltinHandle> discardFunctionHandle =
180: 		m_dialect.discardFunctionHandle();
181: 	if (!discardFunctionHandle)
182: 		return {};
183: 
184: 	return make_vector<Statement>(makeDiscardCall(
185: 		debugDataOf(*_switchStmt.expression),
186: 		m_dialect.builtin(*discardFunctionHandle),
187: 		std::move(*_switchStmt.expression)
188: 	));
189: }
190: 
191: OptionalStatements ControlFlowSimplifier::reduceSingleCaseSwitch(Switch& _switchStmt) const
192: {
193: 	yulAssert(_switchStmt.cases.size() == 1, "Expected only one case!");
194: 
195: 	auto& switchCase = _switchStmt.cases.front();
196: 	langutil::DebugData::ConstPtr debugData = debugDataOf(*_switchStmt.expression);
197: 	if (switchCase.value)
198: 	{
199: 		if (!m_dialect.equalityFunctionHandle())
200: 			return {};
201: 		return make_vector<Statement>(If{
202: 			std::move(_switchStmt.debugData),
203: 			std::make_unique<Expression>(FunctionCall{
204: 				debugData,
205: 				Identifier{debugData, YulName{m_dialect.builtin(*m_dialect.equalityFunctionHandle()).name}},
206: 				{std::move(*switchCase.value), std::move(*_switchStmt.expression)}
207: 			}),
208: 			std::move(switchCase.body)
209: 		});
210: 	}
211: 	else
212: 	{
213: 		if (!m_dialect.discardFunctionHandle())
214: 			return {};
215: 
216: 		return make_vector<Statement>(
217: 			makeDiscardCall(
218: 				debugData,
219: 				m_dialect.builtin(*m_dialect.discardFunctionHandle()),
220: 				std::move(*_switchStmt.expression)
221: 			),
222: 			std::move(switchCase.body)
223: 		);
224: 	}
225: }
226: 
```
10.
File Path: libyul/backends/evm/EVMCodeTransform.cpp
Code Snippet:
```
[&var] = heightAtStart + varIndexReverse;
163: 		if (!m_allowStackOpt)
164: 			continue;
165: 
166: 		if (unreferenced(var))
167: 		{
168: 			if (atTopOfStack)
169: 			{
170: 				m_context->variableStackHeights.erase(&var);
171: 				m_assembly.appendInstruction(evmasm::Instruction::POP);
172: 			}
173: 			else
174: 				m_variablesScheduledForDeletion.insert(&var);
175: 		}
176: 		else
177: 		{
178: 			bool foundUnusedSlot = false;
179: 			for (auto it = m_unusedStackSlots.begin(); it != m_unusedStackSlots.end(); ++it)
180: 			{
181: 				if (m_assembly.stackHeight() - *it > 17)
182: 					continue;
183: 				foundUnusedSlot = true;
184: 				auto slot = static_cast<size_t>(*it);
185: 				m_unusedStackSlots.erase(it);
186: 				m_context->variableStackHeights[&var] = slot;
187: 				if (size_t heightDiff = variableHeightDiff(var, varName, true))
188: 					m_assembly.appendInstruction(evmasm::swapInstruction(static_cast<unsigned>(heightDiff - 1)));
189: 				m_assembly.appendInstruction(evmasm::Instruction::POP);
190: 				break;
191: 			}
192: 			if (!foundUnusedSlot)
193: 				atTopOfStack = false;
194: 		}
195: 	}
196: }
197: 
198: void CodeTransform::stackError(StackTooDeepError _error, int _targetStackHeight)
199: {
200: 	m_assembly.appendInstruction(evmasm::Instruction::INVALID);
201: 	// Correct the stack.
202: 	while (m_assembly.stackHeight() > _targetStackHeight)
203: 		m_assembly.appendInstruction(evmasm::Instruction::POP);
204: 	while (m_assembly.stackHeight() < _targetStackHeight)
205: 		m_assembly.appendConstant(u256(0));
206: 	// Store error.
207: 	m_stackErrors.emplace_back(std::move(_error));
208: 	m_assembly.markAsInvalid();
209: }
210: 
211: void CodeTransform::operator()(Assignment const& _assignment)
212: {
213: 	int height = m_assembly.stackHeight();
214: 	std::visit(*this, *_assignment.value);
215: 	expectDeposit(static_cast<int>(_assignment.variableNames.size()), height);
216: 
217: 	m_assembly.setSourceLocation(originLocationOf(_assignment));
218: 	generateMultiAssignment(_assignment.variableNames);
219: }
220: 
221: void CodeTransform::operator()(ExpressionStatement const& _statement)
222: {
223: 	m_assembly.setSourceLocation(originLocationOf(_statement));
224: 	std::visit(*this, _statement.expression);
225: }
226: 
227: void CodeTransform::operator()(FunctionCall const& _call)
228: {
229: 	yulAssert(m_scope, "");
230: 
231: 	m_assembly.setSourceLocation(originLocationOf(_call));
232: 	if (std::optional<BuiltinHandle> builtinHandle = m_dialect.findBuiltin(_call.functionName.name.str()))
233: 	{
234: 		BuiltinFunctionForEVM const& builtin = m_dialect.builtin(*builtinHandle);
235: 		for (auto&& [i, arg]: _call.arguments | ranges::views::enumerate | ranges::views
```
11.
File Path: libyul/backends/evm/EVMCodeTransform.cpp
Code Snippet:
```
::reverse)
236: 			if (!builtin.literalArgument(i))
237: 				visitExpression(arg);
238: 		m_assembly.setSourceLocation(originLocationOf(_call));
239: 		builtin.generateCode(_call, m_assembly, m_builtinContext);
240: 	}
241: 	else
242: 	{
243: 		AbstractAssembly::LabelID returnLabel = m_assembly.newLabelId();
244: 		m_assembly.appendLabelReference(returnLabel);
245: 
246: 		Scope::Function* function = nullptr;
247: 		yulAssert(m_scope->lookup(_call.functionName.name, GenericVisitor{
248: 			[](Scope::Variable&) { yulAssert(false, "Expected function name."); },
249: 			[&](Scope::Function& _function) { function = &_function; }
250: 		}), "Function name not found.");
251: 		yulAssert(function, "");
252: 		yulAssert(function->numArguments == _call.arguments.size(), "");
253: 		for (auto const& arg: _call.arguments | ranges::views::reverse)
254: 			visitExpression(arg);
255: 		m_assembly.setSourceLocation(originLocationOf(_call));
256: 		m_assembly.appendJumpTo(
257: 			functionEntryID(*function),
258: 			static_cast<int>(function->numReturns) - static_cast<int>(function->numArguments) - 1,
259: 			AbstractAssembly::JumpType::IntoFunction
260: 		);
261: 		m_assembly.appendLabel(returnLabel);
262: 	}
263: }
264: 
265: void CodeTransform::operator()(Identifier const& _identifier)
266: {
267: 	m_assembly.setSourceLocation(originLocationOf(_identifier));
268: 	// First search internals, then externals.
269: 	yulAssert(m_scope, "");
270: 	if (m_scope->lookup(_identifier.name, GenericVisitor{
271: 		[&](Scope::Variable& _var)
272: 		{
273: 			// TODO: opportunity for optimization: Do not DUP if this is the last reference
274: 			// to the top most element of the stack
275: 			if (size_t heightDiff = variableHeightDiff(_var, _identifier.name, false))
276: 				m_assembly.appendInstruction(evmasm::dupInstruction(static_cast<unsigned>(heightDiff)));
277: 			else
278: 				// Store something to balance the stack
279: 				m_assembly.appendConstant(u256(0));
280: 			decreaseReference(_identifier.name, _var);
281: 		},
282: 		[](Scope::Function&)
283: 		{
284: 			yulAssert(false, "Function not removed during desugaring.");
285: 		}
286: 	}))
287: 	{
288: 		return;
289: 	}
290: 	yulAssert(
291: 		m_identifierAccessCodeGen,
292: 		"Identifier not found and no external access available."
293: 	);
294: 	m_identifierAccessCodeGen(_identifier, IdentifierContext::RValue, m_assembly);
295: }
296: 
297: void CodeTransform::operator()(Literal const& _literal)
298: {
299: 	m_assembly.setSourceLocation(originLocationOf(_literal));
300: 	m_assembly.appendConstant(_literal.value.value());
301: }
302: 
303: void CodeTransform::operator()(If const& _if)
304: {
305: 	visitExpression(*_if.condition);
306: 	m_assembly.setSourceLocation(originLocationOf(_if));
307
```
12.
File Path: libyul/backends/evm/EVMCodeTransform.cpp
Code Snippet:
```
{
472: 			while (!stackLayout.empty() && stackLayout.back() != static_cast<int>(stackLayout.size() - 1))
473: 				if (stackLayout.back() < 0)
474: 				{
475: 					m_assembly.appendInstruction(evmasm::Instruction::POP);
476: 					stackLayout.pop_back();
477: 				}
478: 				else
479: 				{
480: 					m_assembly.appendInstruction(evmasm::swapInstruction(static_cast<unsigned>(stackLayout.size()) - static_cast<unsigned>(stackLayout.back()) - 1u));
481: 					std::swap(stackLayout[static_cast<size_t>(stackLayout.back())], stackLayout.back());
482: 				}
483: 			for (size_t i = 0; i < stackLayout.size(); ++i)
484: 				yulAssert(i == static_cast<size_t>(stackLayout[i]), "Error reshuffling stack.");
485: 		}
486: 	}
487: 	m_assembly.appendJump(
488: 		stackHeightBefore - static_cast<int>(_function.returnVariables.size()),
489: 		AbstractAssembly::JumpType::OutOfFunction
490: 	);
491: 	m_assembly.setStackHeight(stackHeightBefore);
492: }
493: 
494: void CodeTransform::operator()(ForLoop const& _forLoop)
495: {
496: 	Scope* originalScope = m_scope;
497: 	// We start with visiting the block, but not finalizing it.
498: 	m_scope = m_info.scopes.at(&_forLoop.pre).get();
499: 	int stackStartHeight = m_assembly.stackHeight();
500: 
501: 	visitStatements(_forLoop.pre.statements);
502: 
503: 	AbstractAssembly::LabelID loopStart = m_assembly.newLabelId();
504: 	AbstractAssembly::LabelID postPart = m_assembly.newLabelId();
505: 	AbstractAssembly::LabelID loopEnd = m_assembly.newLabelId();
506: 
507: 	m_assembly.setSourceLocation(originLocationOf(_forLoop));
508: 	m_assembly.appendLabel(loopStart);
509: 
510: 	visitExpression(*_forLoop.condition);
511: 	m_assembly.setSourceLocation(originLocationOf(_forLoop));
512: 	m_assembly.appendInstruction(evmasm::Instruction::ISZERO);
513: 	m_assembly.appendJumpToIf(loopEnd);
514: 
515: 	int const stackHeightBody = m_assembly.stackHeight();
516: 	m_context->forLoopStack.emplace(Context::ForLoopLabels{ {postPart, stackHeightBody}, {loopEnd, stackHeightBody} });
517: 	(*this)(_forLoop.body);
518: 
519: 	m_assembly.setSourceLocation(originLocationOf(_forLoop));
520: 	m_assembly.appendLabel(postPart);
521: 
522: 	(*this)(_forLoop.post);
523: 
524: 	m_assembly.setSourceLocation(originLocationOf(_forLoop));
525: 	m_assembly.appendJumpTo(loopStart);
526: 	m_assembly.appendLabel(loopEnd);
527: 
528: 	finalizeBlock(_forLoop.pre, stackStartHeight);
529: 	m_context->forLoopStack.pop();
530: 	m_scope = originalScope;
531: }
532: 
533: int CodeTransform::appendPopUntil(int _targetDepth)
534: {
535: 	int const stackDiffAfter = m_assembly.stackHeight() - _targetDepth;
536: 	for (int i = 0; i < stackDiffAfter; ++i)
537: 		m_assembly
```
13.
File Path: libyul/backends/evm/EVMDialect.h
Code Snippet:
```
>
25: 
26: #include <libyul/backends/evm/AbstractAssembly.h>
27: #include <libyul/ASTForward.h>
28: #include <liblangutil/EVMVersion.h>
29: 
30: #include <map>
31: #include <set>
32: 
33: namespace solidity::yul
34: {
35: 
36: struct FunctionCall;
37: class Object;
38: 
39: /**
40:  * Context used during code generation.
41:  */
42: struct BuiltinContext
43: {
44: 	Object const* currentObject = nullptr;
45: 	/// Mapping from named objects to abstract assembly sub IDs.
46: 	std::map<std::string, AbstractAssembly::SubID> subIDs;
47: 
48: 	std::map<Scope::Function const*, AbstractAssembly::FunctionID> functionIDs;
49: };
50: 
51: struct BuiltinFunctionForEVM: public BuiltinFunction
52: {
53: 	std::optional<evmasm::Instruction> instruction;
54: 	/// Function to generate code for the given function call and append it to the abstract
55: 	/// assembly. Expects all non-literal arguments of the call to be on stack in reverse order
56: 	/// (i.e. right-most argument pushed first).
57: 	/// Expects the caller to set the source location.
58: 	std::function<void(FunctionCall const&, AbstractAssembly&, BuiltinContext&)> generateCode;
59: };
60: 
61: 
62: /**
63:  * Yul dialect for EVM as a backend.
64:  * The main difference is that the builtin functions take an AbstractAssembly for the
65:  * code generation.
66:  */
67: class EVMDialect: public Dialect
68: {
69: public:
70: 	/// Constructor, should only be used internally. Use the factory functions below.
71: 	EVMDialect(langutil::EVMVersion _evmVersion, std::optional<uint8_t> _eofVersion, bool _objectAccess);
72: 
73: 	std::optional<BuiltinHandle> findBuiltin(std::string_view _name) const override;
74: 
75: 	BuiltinFunctionForEVM const& builtin(BuiltinHandle const& _handle) const override;
76: 
77: 	bool reservedIdentifier(std::string_view _name) const override;
78: 
79: 	std::optional<BuiltinHandle> discardFunctionHandle() const override { return m_discardFunction; }
80: 	std::optional<BuiltinHandle> equalityFunctionHandle() const override { return m_equalityFunction; }
81: 	std::optional<BuiltinHandle> booleanNegationFunctionHandle() const override { return m_booleanNegationFunction; }
82: 	std::optional<BuiltinHandle> memoryStoreFunctionHandle() const override { return m_memoryStoreFunction; }
83: 	std::optional<BuiltinHandle> memoryLoadFunctionHandle() const override { return m_memoryLoadFunction; }
84: 	std::optional<BuiltinHandle> storageStoreFunctionHandle() const override { return m_storageStoreFunction; }
85: 	std::optional<BuiltinHandle> storageLoadFunctionHandle() const override { return m_storageLoadFunction; }
86: 	std::optional<BuiltinHandle> hashFunctionHandle() const override { return m_hashFunction; }
87: 
88: 	static EVMDialect const& strictAssemblyForEVM(langutil::EVMVersion _evmVersion, std::optional<uint8_t> _eofVersion);
89
```
14.
File Path: libyul/backends/evm/EVMCodeTransform.cpp
Code Snippet:
```
	else
278: 				// Store something to balance the stack
279: 				m_assembly.appendConstant(u256(0));
280: 			decreaseReference(_identifier.name, _var);
281: 		},
282: 		[](Scope::Function&)
283: 		{
284: 			yulAssert(false, "Function not removed during desugaring.");
285: 		}
286: 	}))
287: 	{
288: 		return;
289: 	}
290: 	yulAssert(
291: 		m_identifierAccessCodeGen,
292: 		"Identifier not found and no external access available."
293: 	);
294: 	m_identifierAccessCodeGen(_identifier, IdentifierContext::RValue, m_assembly);
295: }
296: 
297: void CodeTransform::operator()(Literal const& _literal)
298: {
299: 	m_assembly.setSourceLocation(originLocationOf(_literal));
300: 	m_assembly.appendConstant(_literal.value.value());
301: }
302: 
303: void CodeTransform::operator()(If const& _if)
304: {
305: 	visitExpression(*_if.condition);
306: 	m_assembly.setSourceLocation(originLocationOf(_if));
307: 	m_assembly.appendInstruction(evmasm::Instruction::ISZERO);
308: 	AbstractAssembly::LabelID end = m_assembly.newLabelId();
309: 	m_assembly.appendJumpToIf(end);
310: 	(*this)(_if.body);
311: 	m_assembly.setSourceLocation(originLocationOf(_if));
312: 	m_assembly.appendLabel(end);
313: }
314: 
315: void CodeTransform::operator()(Switch const& _switch)
316: {
317: 	visitExpression(*_switch.expression);
318: 	int expressionHeight = m_assembly.stackHeight();
319: 	std::map<Case const*, AbstractAssembly::LabelID> caseBodies;
320: 	AbstractAssembly::LabelID end = m_assembly.newLabelId();
321: 	for (Case const& c: _switch.cases)
322: 	{
323: 		if (c.value)
324: 		{
325: 			(*this)(*c.value);
326: 			m_assembly.setSourceLocation(originLocationOf(c));
327: 			AbstractAssembly::LabelID bodyLabel = m_assembly.newLabelId();
328: 			caseBodies[&c] = bodyLabel;
329: 			yulAssert(m_assembly.stackHeight() == expressionHeight + 1, "");
330: 			m_assembly.appendInstruction(evmasm::dupInstruction(2));
331: 			m_assembly.appendInstruction(evmasm::Instruction::EQ);
332: 			m_assembly.appendJumpToIf(bodyLabel);
333: 		}
334: 		else
335: 			// default case
336: 			(*this)(c.body);
337: 	}
338: 	m_assembly.setSourceLocation(originLocationOf(_switch));
339: 	m_assembly.appendJumpTo(end);
340: 
341: 	size_t numCases = caseBodies.size();
342: 	for (auto const& c: caseBodies)
343: 	{
344: 		m_assembly.setSourceLocation(originLocationOf(*c.first));
345: 		m_assembly.appendLabel(c.second);
346: 		(*this)(c.first->body);
347: 		// Avoid useless "jump to next" for the last case.
348: 		if (--numCases > 0)
349: 		{
350: 			m_assembly.setSourceLocation(originLocationOf(*c.first));
351: 			m_assembly.appendJump
```
15.
File Path: libyul/AsmAnalysis.cpp
Code Snippet:
```
 deprecated. "
327: 				"Note that, starting from the Cancun hard fork, the underlying opcode no longer deletes the code and "
328: 				"data associated with an account and only transfers its Ether to the beneficiary, "
329: 				"unless executed in the same transaction in which the contract was created (see EIP-6780). "
330: 				"Any use in newly deployed contracts is strongly discouraged even if the new behavior is taken into account. "
331: 				"Future changes to the EVM might further reduce the functionality of the opcode."
332: 			);
333: 		else if (
334: 			m_evmVersion.supportsTransientStorage() &&
335: 			_funCall.functionName.name == "tstore"_yulname &&
336: 			!m_errorReporter.hasError({2394})
337: 		)
338: 			m_errorReporter.warning(
339: 				2394_error,
340: 				nativeLocationOf(_funCall.functionName),
341: 				"Transient storage as defined by EIP-1153 can break the composability of smart contracts: "
342: 				"Since transient storage is cleared only at the end of the transaction and not at the end of the outermost call frame to the contract within a transaction, "
343: 				"your contract may unintentionally misbehave when invoked multiple times in a complex transaction. "
344: 				"To avoid this, be sure to clear all transient storage at the end of any call to your contract. "
345: 				"The use of transient storage for reentrancy guards that are cleared at the end of the call is safe."
346: 			);
347: 
348: 		BuiltinFunction const& f = m_dialect.builtin(*handle);
349: 		numParameters = f.numParameters;
350: 		numReturns = f.numReturns;
351: 		if (!f.literalArguments.empty())
352: 			literalArguments = &f.literalArguments;
353: 
354: 		validateInstructions(_funCall);
355: 		m_sideEffects += f.sideEffects;
356: 	}
357: 	else if (m_currentScope->lookup(_funCall.functionName.name, GenericVisitor{
358: 		[&](Scope::Variable const&)
359: 		{
360: 			m_errorReporter.typeError(
361: 				4202_error,
362: 				nativeLocationOf(_funCall.functionName),
363: 				"Attempt to call variable instead of function."
364: 			);
365: 		},
366: 		[&](Scope::Function const& _fun)
367: 		{
368: 			numParameters = _fun.numArguments;
369: 			numReturns = _fun.numReturns;
370: 		}
371: 	}))
372: 	{
373: 		if (m_resolver)
374: 			// We found a local reference, make sure there is no external reference.
375: 			m_resolver(
376: 				_funCall.functionName,
377: 				yul::IdentifierContext::NonExternal,
378: 				m_currentScope->insideFunction()
379: 			);
380: 	}
381: 	else
382: 	{
383: 		if (!validateInstructions(_funCall))
384: 			m_errorReporter.declarationError(
385: 				4619_error,
386: 				nativeLocationOf(_funCall.functionName),
387: 				"Function \"" + _funCall.functionName.name.str() + "\" not found."
388: 			);
389: 		yulAssert(!watcher.ok(), "Expected a reported error.");
390: 	}
391: 
392
```
16.
File Path: libyul/backends/evm/EVMCodeTransform.cpp
Code Snippet:
```
102: 
103: 	for (auto const& identifier: m_scope->identifiers)
104: 		if (Scope::Variable const* var = std::get_if<Scope::Variable>(&identifier.second))
105: 			if (m_variablesScheduledForDeletion.count(var))
106: 				deleteVariable(*var);
107: 	// Directly in a function body block, we can also delete the function arguments,
108: 	// which live in the virtual function scope.
109: 	// However, doing so after the return variables are already allocated, seems to have an adverse
110: 	// effect, so we only do it before that.
111: 	if (!returnVariablesAndFunctionExitAreSetup() && !m_scope->functionScope && m_scope->superScope && m_scope->superScope->functionScope)
112: 		for (auto const& identifier: m_scope->superScope->identifiers)
113: 			if (Scope::Variable const* var = std::get_if<Scope::Variable>(&identifier.second))
114: 				if (m_variablesScheduledForDeletion.count(var))
115: 					deleteVariable(*var);
116: 
117: 	if (_popUnusedSlotsAtStackTop)
118: 		while (m_unusedStackSlots.count(m_assembly.stackHeight() - 1))
119: 		{
120: 			yulAssert(m_unusedStackSlots.erase(m_assembly.stackHeight() - 1), "");
121: 			m_assembly.appendInstruction(evmasm::Instruction::POP);
122: 		}
123: }
124: 
125: void CodeTransform::deleteVariable(Scope::Variable const& _var)
126: {
127: 	yulAssert(m_allowStackOpt, "");
128: 	yulAssert(m_context->variableStackHeights.count(&_var) > 0, "");
129: 	m_unusedStackSlots.insert(static_cast<int>(m_context->variableStackHeights[&_var]));
130: 	m_context->variableStackHeights.erase(&_var);
131: 	m_context->variableReferences.erase(&_var);
132: 	m_variablesScheduledForDeletion.erase(&_var);
133: }
134: 
135: void CodeTransform::operator()(VariableDeclaration const& _varDecl)
136: {
137: 	yulAssert(m_scope, "");
138: 
139: 	size_t const numVariables = _varDecl.variables.size();
140: 	auto heightAtStart = static_cast<size_t>(m_assembly.stackHeight());
141: 	if (_varDecl.value)
142: 	{
143: 		std::visit(*this, *_varDecl.value);
144: 		expectDeposit(static_cast<int>(numVariables), static_cast<int>(heightAtStart));
145: 		freeUnusedVariables(false);
146: 	}
147: 	else
148: 	{
149: 		m_assembly.setSourceLocation(originLocationOf(_varDecl));
150: 		size_t variablesLeft = numVariables;
151: 		while (variablesLeft--)
152: 			m_assembly.appendConstant(u256(0));
153: 	}
154: 
155: 	m_assembly.setSourceLocation(originLocationOf(_varDecl));
156: 	bool atTopOfStack = true;
157: 	for (size_t varIndex = 0; varIndex < numVariables; ++varIndex)
158: 	{
159: 		size_t varIndexReverse = numVariables - 1 - varIndex;
160: 		YulName varName = _varDecl.variables[varIndexReverse].name;
161: 		auto& var = std::get<Scope::Variable>(m_scope->identifiers.at(varName));
162: 		m_context->variableStackHeights
```
17.
File Path: libyul/optimiser/Semantics.cpp
Code Snippet:
```
: 	else if (
202: 		std::holds_alternative<Assignment>(_statement) &&
203: 		containsNonContinuingFunctionCall(*std::get<Assignment>(_statement).value)
204: 	)
205: 		return ControlFlow::Terminate;
206: 	else if (
207: 		std::holds_alternative<ExpressionStatement>(_statement) &&
208: 		containsNonContinuingFunctionCall(std::get<ExpressionStatement>(_statement).expression)
209: 	)
210: 		return ControlFlow::Terminate;
211: 	else if (std::holds_alternative<Break>(_statement))
212: 		return ControlFlow::Break;
213: 	else if (std::holds_alternative<Continue>(_statement))
214: 		return ControlFlow::Continue;
215: 	else if (std::holds_alternative<Leave>(_statement))
216: 		return ControlFlow::Leave;
217: 	else
218: 		return ControlFlow::FlowOut;
219: }
220: 
221: bool TerminationFinder::containsNonContinuingFunctionCall(Expression const& _expr)
222: {
223: 	if (auto functionCall = std::get_if<FunctionCall>(&_expr))
224: 	{
225: 		for (auto const& arg: functionCall->arguments)
226: 			if (containsNonContinuingFunctionCall(arg))
227: 				return true;
228: 
229: 		if (std::optional<BuiltinHandle> const builtinHandle = m_dialect.findBuiltin(functionCall->functionName.name.str()))
230: 			return !m_dialect.builtin(*builtinHandle).controlFlowSideEffects.canContinue;
231: 		else if (m_functionSideEffects && m_functionSideEffects->count(functionCall->functionName.name))
232: 			return !m_functionSideEffects->at(functionCall->functionName.name).canContinue;
233: 	}
234: 	return false;
235: }
```
18.
File Path: libyul/backends/evm/NoOutputAssembly.h
Code Snippet:
```
71: 	void appendJumpToIf(LabelID _labelId, JumpType _jumpType) override;
72: 
73: 	void appendAssemblySize() override;
74: 	std::pair<std::shared_ptr<AbstractAssembly>, SubID> createSubAssembly(bool _creation, std::string _name = "") override;
75: 	FunctionID registerFunction(uint8_t _args, uint8_t _rets) override;
76: 	void beginFunction(FunctionID) override;
77: 	void endFunction() override;
78: 	void appendFunctionCall(FunctionID _functionID) override;
79: 	void appendFunctionReturn() override;
80: 	void appendDataOffset(std::vector<SubID> const& _subPath) override;
81: 	void appendDataSize(std::vector<SubID> const& _subPath) override;
82: 	SubID appendData(bytes const& _data) override;
83: 
84: 	void appendToAuxiliaryData(bytes const&) override {}
85: 
86: 	void appendImmutable(std::string const& _identifier) override;
87: 	void appendImmutableAssignment(std::string const& _identifier) override;
88: 
89: 	void appendAuxDataLoadN(uint16_t) override;
90: 	void appendEOFCreate(ContainerID) override;
91: 	void appendReturnContract(ContainerID) override;
92: 
93: 	void markAsInvalid() override {}
94: 
95: 	langutil::EVMVersion evmVersion() const override { return m_evmVersion; }
96: 
97: private:
98: 	NoOutputAssemblyContext m_context = {};
99: 	int m_stackHeight = 0;
100: 	FunctionID m_currentFunctionID = 0;
101: 	langutil::EVMVersion m_evmVersion;
102: };
103: 
104: 
105: /**
106:  * EVM dialect that does not generate any code.
107:  */
108: class NoOutputEVMDialect: public EVMDialect
109: {
110: public:
111: 	explicit NoOutputEVMDialect(EVMDialect const& _copyFrom);
112: 
113: 	BuiltinFunctionForEVM const& builtin(BuiltinHandle const& _handle) const override;
114: };
115: 
116: 
117: }
```
19.
File Path: libyul/backends/evm/EVMCodeTransform.cpp
Code Snippet:
```
329: 			yulAssert(m_assembly.stackHeight() == expressionHeight + 1, "");
330: 			m_assembly.appendInstruction(evmasm::dupInstruction(2));
331: 			m_assembly.appendInstruction(evmasm::Instruction::EQ);
332: 			m_assembly.appendJumpToIf(bodyLabel);
333: 		}
334: 		else
335: 			// default case
336: 			(*this)(c.body);
337: 	}
338: 	m_assembly.setSourceLocation(originLocationOf(_switch));
339: 	m_assembly.appendJumpTo(end);
340: 
341: 	size_t numCases = caseBodies.size();
342: 	for (auto const& c: caseBodies)
343: 	{
344: 		m_assembly.setSourceLocation(originLocationOf(*c.first));
345: 		m_assembly.appendLabel(c.second);
346: 		(*this)(c.first->body);
347: 		// Avoid useless "jump to next" for the last case.
348: 		if (--numCases > 0)
349: 		{
350: 			m_assembly.setSourceLocation(originLocationOf(*c.first));
351: 			m_assembly.appendJumpTo(end);
352: 		}
353: 	}
354: 
355: 	m_assembly.setSourceLocation(originLocationOf(_switch));
356: 	m_assembly.appendLabel(end);
357: 	m_assembly.appendInstruction(evmasm::Instruction::POP);
358: }
359: 
360: void CodeTransform::operator()(FunctionDefinition const& _function)
361: {
362: 	yulAssert(m_scope, "");
363: 	yulAssert(m_scope->identifiers.count(_function.name), "");
364: 	Scope::Function& function = std::get<Scope::Function>(m_scope->identifiers.at(_function.name));
365: 
366: 	size_t height = 1;
367: 	yulAssert(m_info.scopes.at(&_function.body), "");
368: 	Scope* virtualFunctionScope = m_info.scopes.at(m_info.virtualBlocks.at(&_function).get()).get();
369: 	yulAssert(virtualFunctionScope, "");
370: 	for (auto const& v: _function.parameters | ranges::views::reverse)
371: 	{
372: 		auto& var = std::get<Scope::Variable>(virtualFunctionScope->identifiers.at(v.name));
373: 		m_context->variableStackHeights[&var] = height++;
374: 	}
375: 
376: 	m_assembly.setSourceLocation(originLocationOf(_function));
377: 	int const stackHeightBefore = m_assembly.stackHeight();
378: 
379: 	m_assembly.appendLabel(functionEntryID(function));
380: 
381: 	m_assembly.setStackHeight(static_cast<int>(height));
382: 
383: 	CodeTransform subTransform(
384: 		m_assembly,
385: 		m_info,
386: 		_function.body,
387: 		m_allowStackOpt,
388: 		m_dialect,
389: 		m_builtinContext,
390: 		m_identifierAccessCodeGen,
391: 		m_useNamedLabelsForFunctions,
392: 		m_context,
393: 		_function.returnVariables,
394: 		m_assembly.newLabelId()
395: 	);
396: 	subTransform.m_scope = virtualFunctionScope;
397: 
398: 	if (m_allowStackOpt)
399: 		// Immediately delete entirely unused parameters.
400: 		for (auto const& v: _function.parameters | ranges::views::reverse)
401: 		{
402: 			auto& var = std
```
20.
File Path: libyul/optimiser/CommonSubexpressionEliminator.cpp
Code Snippet:
```
CommonSubexpressionEliminator(
47: 	Dialect const& _dialect,
48: 	std::map<YulName, SideEffects> _functionSideEffects
49: ):
50: 	DataFlowAnalyzer(_dialect, MemoryAndStorage::Ignore, std::move(_functionSideEffects))
51: {
52: }
53: 
54: void CommonSubexpressionEliminator::operator()(FunctionDefinition& _fun)
55: {
56: 	ScopedSaveAndRestore returnVariables(m_returnVariables, {});
57: 	ScopedSaveAndRestore replacementCandidates(m_replacementCandidates, {});
58: 
59: 	for (auto const& v: _fun.returnVariables)
60: 		m_returnVariables.insert(v.name);
61: 
62: 	DataFlowAnalyzer::operator()(_fun);
63: }
64: 
65: void CommonSubexpressionEliminator::visit(Expression& _e)
66: {
67: 	bool descend = true;
68: 	// If this is a function call to a function that requires literal arguments,
69: 	// do not try to simplify there.
70: 	if (std::holds_alternative<FunctionCall>(_e))
71: 	{
72: 		FunctionCall& funCall = std::get<FunctionCall>(_e);
73: 
74: 		if (std::optional<BuiltinHandle> builtinHandle = m_dialect.findBuiltin(funCall.functionName.name.str()))
75: 		{
76: 			BuiltinFunction const& builtin = m_dialect.builtin(*builtinHandle);
77: 			for (size_t i = funCall.arguments.size(); i > 0; i--)
78: 				// We should not modify function arguments that have to be literals
79: 				// Note that replacing the function call entirely is fine,
80: 				// if the function call is movable.
81: 				if (!builtin.literalArgument(i - 1))
82: 					visit(funCall.arguments[i - 1]);
83: 
84: 			descend = false;
85: 		}
86: 	}
87: 
88: 	// We visit the inner expression first to first simplify inner expressions,
89: 	// which hopefully allows more matches.
90: 	// Note that the DataFlowAnalyzer itself only has code for visiting Statements,
91: 	// so this basically invokes the AST walker directly and thus post-visiting
92: 	// is also fine with regards to data flow analysis.
93: 	if (descend)
94: 		DataFlowAnalyzer::visit(_e);
95: 
96: 	if (Identifier const* identifier = std::get_if<Identifier>(&_e))
97: 	{
98: 		YulName identifierName = identifier->name;
99: 		if (AssignedValue const* assignedValue = variableValue(identifierName))
100: 		{
101: 			assertThrow(assignedValue->value, OptimizerException, "");
102: 			if (Identifier const* value = std::get_if<Identifier>(assignedValue->value))
103: 				if (inScope(value->name))
104: 					_e = Identifier{debugDataOf(_e), value->name};
105: 		}
106: 	}
107: 	else if (auto const* candidates = util::valueOrNullptr(m_replacementCandidates, _e))
108: 		for (auto const& variable: *candidates)
109: 			if (AssignedValue const* value = variableValue(variable))
110: 			{
111: 				assertThrow(value->value, OptimizerException, "");
112: 				// Prevent using the default value of return variables
113: 				//
```
21.
File Path: libyul/optimiser/Semantics.cpp
Code Snippet:
```
()))
81: 		m_sideEffects += m_dialect.builtin(*builtinHandle).sideEffects;
82: 	else if (m_functionSideEffects && m_functionSideEffects->count(functionName))
83: 		m_sideEffects += m_functionSideEffects->at(functionName);
84: 	else
85: 		m_sideEffects += SideEffects::worst();
86: }
87: 
88: bool MSizeFinder::containsMSize(Dialect const& _dialect, Block const& _ast)
89: {
90: 	MSizeFinder finder(_dialect);
91: 	finder(_ast);
92: 	return finder.m_msizeFound;
93: }
94: 
95: bool MSizeFinder::containsMSize(Dialect const& _dialect, Object const& _object)
96: {
97: 	if (containsMSize(_dialect, _object.code()->root()))
98: 		return true;
99: 
100: 	for (std::shared_ptr<ObjectNode> const& node: _object.subObjects)
101: 		if (auto const* object = dynamic_cast<Object const*>(node.get()))
102: 			if (containsMSize(_dialect, *object))
103: 				return true;
104: 
105: 	return false;
106: }
107: 
108: void MSizeFinder::operator()(FunctionCall const& _functionCall)
109: {
110: 	ASTWalker::operator()(_functionCall);
111: 
112: 	if (std::optional<BuiltinHandle> builtinHandle = m_dialect.findBuiltin(_functionCall.functionName.name.str()))
113: 		if (m_dialect.builtin(*builtinHandle).isMSize)
114: 			m_msizeFound = true;
115: }
116: 
117: std::map<YulName, SideEffects> SideEffectsPropagator::sideEffects(
118: 	Dialect const& _dialect,
119: 	CallGraph const& _directCallGraph
120: )
121: {
122: 	// Any loop currently makes a function non-movable, because
123: 	// it could be a non-terminating loop.
124: 	// The same is true for any function part of a call cycle.
125: 	// In the future, we should refine that, because the property
126: 	// is actually a bit different from "not movable".
127: 
128: 	std::map<YulName, SideEffects> ret;
129: 	for (auto const& function: _directCallGraph.functionsWithLoops + _directCallGraph.recursiveFunctions())
130: 	{
131: 		ret[function].movable = false;
132: 		ret[function].canBeRemoved = false;
133: 		ret[function].canBeRemovedIfNoMSize = false;
134: 		ret[function].cannotLoop = false;
135: 	}
136: 
137: 	for (auto const& call: _directCallGraph.functionCalls)
138: 	{
139: 		YulName funName = call.first;
140: 		SideEffects sideEffects;
141: 		auto _visit = [&, visited = std::set<YulName>{}](YulName _function, auto&& _recurse) mutable {
142: 			if (!visited.insert(_function).second)
143: 				return;
144: 			if (sideEffects == SideEffects::worst())
145: 				return;
146: 			if (std::optional<BuiltinHandle> builtinHandle = _dialect.findBuiltin(_function.str()))
147: 				sideEffects += _dialect.builtin
```
22.
File Path: libyul/optimiser/ExpressionSplitter.cpp
Code Snippet:
```
0: /*
1: 	This file is part of solidity.
2: 
3: 	solidity is free software: you can redistribute it and/or modify
4: 	it under the terms of the GNU General Public License as published by
5: 	the Free Software Foundation, either version 3 of the License, or
6: 	(at your option) any later version.
7: 
8: 	solidity is distributed in the hope that it will be useful,
9: 	but WITHOUT ANY WARRANTY; without even the implied warranty of
10: 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
11: 	GNU General Public License for more details.
12: 
13: 	You should have received a copy of the GNU General Public License
14: 	along with solidity.  If not, see <http://www.gnu.org/licenses/>.
15: */
16: // SPDX-License-Identifier: GPL-3.0
17: /**
18:  * Optimiser component that turns complex expressions into multiple variable
19:  * declarations.
20:  */
21: 
22: #include <libyul/optimiser/ExpressionSplitter.h>
23: 
24: #include <libyul/optimiser/OptimiserStep.h>
25: 
26: #include <libyul/AST.h>
27: #include <libyul/Dialect.h>
28: 
29: #include <libsolutil/CommonData.h>
30: 
31: using namespace solidity;
32: using namespace solidity::yul;
33: using namespace solidity::util;
34: using namespace solidity::langutil;
35: 
36: void ExpressionSplitter::run(OptimiserStepContext& _context, Block& _ast)
37: {
38: 	ExpressionSplitter{_context.dialect, _context.dispenser}(_ast);
39: }
40: 
41: void ExpressionSplitter::operator()(FunctionCall& _funCall)
42: {
43: 	std::optional<BuiltinHandle> builtinHandle = m_dialect.findBuiltin(_funCall.functionName.name.str());
44: 
45: 	for (size_t i = _funCall.arguments.size(); i > 0; i--)
46: 		if (!builtinHandle || !m_dialect.builtin(*builtinHandle).literalArgument(i - 1))
47: 			outlineExpression(_funCall.arguments[i - 1]);
48: }
49: 
50: void ExpressionSplitter::operator()(If& _if)
51: {
52: 	outlineExpression(*_if.condition);
53: 	(*this)(_if.body);
54: }
55: 
56: void ExpressionSplitter::operator()(Switch& _switch)
57: {
58: 	outlineExpression(*_switch.expression);
59: 	for (auto& _case: _switch.cases)
60: 		// Do not visit the case expression, nothing to split there.
61: 		(*this)(_case.body);
62: }
63: 
64: void ExpressionSplitter::operator()(ForLoop& _loop)
65: {
66: 	(*this)(_loop.pre);
67: 	// Do not visit the condition because we cannot split expressions there.
68: 	(*this)(_loop.post);
69: 	(*this)(_loop.body);
70: }
71: 
72: void ExpressionSplitter::operator()(Block& _block)
73: {
74: 	std::vector<Statement> saved;
75: 	swap(saved, m_statementsToPrefix);
76: 
77: 	std::function<std::optional<std::vector<
```
23.
File Path: libyul/optimiser/ControlFlowSimplifier.cpp
Code Snippet:
```
	debugDataOf(*_switchStmt.expression),
186: 		m_dialect.builtin(*discardFunctionHandle),
187: 		std::move(*_switchStmt.expression)
188: 	));
189: }
190: 
191: OptionalStatements ControlFlowSimplifier::reduceSingleCaseSwitch(Switch& _switchStmt) const
192: {
193: 	yulAssert(_switchStmt.cases.size() == 1, "Expected only one case!");
194: 
195: 	auto& switchCase = _switchStmt.cases.front();
196: 	langutil::DebugData::ConstPtr debugData = debugDataOf(*_switchStmt.expression);
197: 	if (switchCase.value)
198: 	{
199: 		if (!m_dialect.equalityFunctionHandle())
200: 			return {};
201: 		return make_vector<Statement>(If{
202: 			std::move(_switchStmt.debugData),
203: 			std::make_unique<Expression>(FunctionCall{
204: 				debugData,
205: 				Identifier{debugData, YulName{m_dialect.builtin(*m_dialect.equalityFunctionHandle()).name}},
206: 				{std::move(*switchCase.value), std::move(*_switchStmt.expression)}
207: 			}),
208: 			std::move(switchCase.body)
209: 		});
210: 	}
211: 	else
212: 	{
213: 		if (!m_dialect.discardFunctionHandle())
214: 			return {};
215: 
216: 		return make_vector<Statement>(
217: 			makeDiscardCall(
218: 				debugData,
219: 				m_dialect.builtin(*m_dialect.discardFunctionHandle()),
220: 				std::move(*_switchStmt.expression)
221: 			),
222: 			std::move(switchCase.body)
223: 		);
224: 	}
225: }
226: 
```
24.
File Path: libyul/optimiser/ForLoopConditionIntoBody.cpp
Code Snippet:
```
 
22: #include <libsolutil/CommonData.h>
23: 
24: using namespace solidity;
25: using namespace solidity::yul;
26: 
27: void ForLoopConditionIntoBody::run(OptimiserStepContext& _context, Block& _ast)
28: {
29: 	ForLoopConditionIntoBody{_context.dialect}(_ast);
30: }
31: 
32: void ForLoopConditionIntoBody::operator()(ForLoop& _forLoop)
33: {
34: 	if (
35: 		m_dialect.booleanNegationFunctionHandle() &&
36: 		!std::holds_alternative<Literal>(*_forLoop.condition) &&
37: 		!std::holds_alternative<Identifier>(*_forLoop.condition)
38: 	)
39: 	{
40: 		langutil::DebugData::ConstPtr debugData = debugDataOf(*_forLoop.condition);
41: 
42: 		_forLoop.body.statements.emplace(
43: 			begin(_forLoop.body.statements),
44: 			If {
45: 				debugData,
46: 				std::make_unique<Expression>(
47: 					FunctionCall {
48: 						debugData,
49: 						{debugData, YulName{m_dialect.builtin(*m_dialect.booleanNegationFunctionHandle()).name}},
50: 						util::make_vector<Expression>(std::move(*_forLoop.condition))
51: 					}
52: 				),
53: 				Block {debugData, util::make_vector<Statement>(Break{{}})}
54: 			}
55: 		);
56: 		_forLoop.condition = std::make_unique<Expression>(
57: 			Literal {
58: 				debugData,
59: 				LiteralKind::Boolean,
60: 				LiteralValue{true}
61: 			}
62: 		);
63: 	}
64: 	ASTModifier::operator()(_forLoop);
65: }
66: 
```
25.
File Path: libyul/optimiser/UnusedStoreEliminator.cpp
Code Snippet:
```
ialect);
69: 	if (evmDialect && evmDialect->providesObjectAccess())
70: 		rse.clearActive(Location::Memory);
71: 	else
72: 		rse.markActiveAsUsed(Location::Memory);
73: 	rse.markActiveAsUsed(Location::Storage);
74: 	rse.m_storesToRemove += rse.m_allStores - rse.m_usedStores;
75: 
76: 	std::set<Statement const*> toRemove{rse.m_storesToRemove.begin(), rse.m_storesToRemove.end()};
77: 	StatementRemover remover{toRemove};
78: 	remover(_ast);
79: }
80: 
81: UnusedStoreEliminator::UnusedStoreEliminator(
82: 	Dialect const& _dialect,
83: 	std::map<YulName, SideEffects> const& _functionSideEffects,
84: 	std::map<YulName, ControlFlowSideEffects> _controlFlowSideEffects,
85: 	std::map<YulName, AssignedValue> const& _ssaValues,
86: 	bool _ignoreMemory
87: ):
88: 	UnusedStoreBase(_dialect),
89: 	m_ignoreMemory(_ignoreMemory),
90: 	m_functionSideEffects(_functionSideEffects),
91: 	m_controlFlowSideEffects(_controlFlowSideEffects),
92: 	m_ssaValues(_ssaValues),
93: 	m_knowledgeBase(_ssaValues)
94: {}
95: 
96: void UnusedStoreEliminator::operator()(FunctionCall const& _functionCall)
97: {
98: 	UnusedStoreBase::operator()(_functionCall);
99: 
100: 	for (Operation const& op: operationsFromFunctionCall(_functionCall))
101: 		applyOperation(op);
102: 
103: 	ControlFlowSideEffects sideEffects;
104: 	if (std::optional<BuiltinHandle> const builtinHandle = m_dialect.findBuiltin(_functionCall.functionName.name.str()))
105: 		sideEffects = m_dialect.builtin(*builtinHandle).controlFlowSideEffects;
106: 	else
107: 		sideEffects = m_controlFlowSideEffects.at(_functionCall.functionName.name);
108: 
109: 	if (sideEffects.canTerminate)
110: 		markActiveAsUsed(Location::Storage);
111: 	if (!sideEffects.canContinue)
112: 	{
113: 		clearActive(Location::Memory);
114: 		if (!sideEffects.canTerminate)
115: 			clearActive(Location::Storage);
116: 	}
117: }
118: 
119: void UnusedStoreEliminator::operator()(FunctionDefinition const& _functionDefinition)
120: {
121: 	ScopedSaveAndRestore storeOperations(m_storeOperations, {});
122: 	UnusedStoreBase::operator()(_functionDefinition);
123: }
124: 
125: 
126: void UnusedStoreEliminator::operator()(Leave const&)
127: {
128: 	markActiveAsUsed();
129: }
130: 
131: void UnusedStoreEliminator::visit(Statement const& _statement)
132: {
133: 	using evmasm::Instruction;
134: 
135: 	UnusedStoreBase::visit(_statement);
136: 
137: 	auto const* exprStatement = std::get_if<ExpressionStatement>(&_statement);
138: 	if (!exprStatement)
139: 		return;
140: 
141: 	FunctionCall const* funCall = std::get_if<FunctionCall>(&exprStatement->expression);
142: 	yulAssert(funCall);
143: 	std::optional<Instruction> instruction = toEVMInstruction(m
```
<END_OF_CONTEXT>
<START_OF_USER_PROMPT>
Find the true definition of None that is being called in function builtin

void CodeTransform::operator()(FunctionCall const& _call)
{
	yulAssert(m_scope, "");

	m_assembly.setSourceLocation(originLocationOf(_call));
	if (std::optional<BuiltinHandle> builtinHandle = m_dialect.findBuiltin(_call.functionName.name.str()))
	{
		BuiltinFunctionForEVM const& builtin = m_dialect.builtin(*builtinHandle);
		for (auto&& [i, arg]: _call.arguments | ranges::views::enumerate | ranges::views 

1. Analyze the calling function context to understand how None is being used
2. Examine the retrieved documents between <START_OF_CONTEXT> and <END_OF_CONTEXT> to identify all candidate definitions of None
3. Determine which specific definition is being called based on:
   - Function parameter types and counts
   - Template arguments (if applicable)
   - Object type and inheritance hierarchy
   - Function signature matching
   - Context of the call site
4. If multiple valid candidates exist, explain why one is more likely than others
5. Provide the exact code snippet with line numbers if available
6. Include the file path for each found declaration/definition
7. If the target cannot be resolved with the given context, state this clearly
---------- Output Format ----------
Resolved Definition:
[File path]: [Line numbers]
[Code snippet]


<END_OF_USER_PROMPT>
