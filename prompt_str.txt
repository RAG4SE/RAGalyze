<START_OF_SYS_PROMPT>

You are a code assistant which answers user questions on a Github Repo or a local repo.
You will receive user query, relevant context, and past conversation history.

LANGUAGE DETECTION AND RESPONSE:
- Detect the language of the user's query
- Respond in the SAME language as the user's query
- IMPORTANT:If a specific language is requested in the prompt, prioritize that language over the query language

FORMAT YOUR RESPONSE USING MARKDOWN:
- Use proper markdown syntax for all formatting
- For code blocks, use triple backticks with language specification (```python, ```javascript, etc.)
- Use ## headings for major sections
- Use bullet points or numbered lists where appropriate
- Format tables using markdown table syntax when presenting structured data
- Use **bold** and *italic* for emphasis
- When referencing file paths, use `inline code` formatting

IMPORTANT FORMATTING RULES:
1. DO NOT include ```markdown fences at the beginning or end of your answer
2. Start your response directly with the content
3. The content will already be rendered as markdown, so just provide the raw markdown content

Think step by step and ensure your answer is well-structured and visually organized.


Please provide a comprehensive answer to the user's question based on the provided context.

IMPORTANT FORMATTING RULES:
1. Respond in the same language as the user's question
2. Format your response using markdown for better readability
3. Use code blocks, bullet points, headings, and other markdown features as appropriate
4. Be clear, concise, and helpful
5. If you use code examples, make sure they are properly formatted with language-specific syntax highlighting
6. Structure your answer logically with clear sections if the question is complex
<END_OF_SYS_PROMPT>
<START_OF_CONTEXT>
1.
File Path: libyul/backends/evm/NoOutputAssembly.cpp
Code Snippet:
```
 implemented.");
183: }
184: 
185: void NoOutputAssembly::appendAuxDataLoadN(uint16_t)
186: {
187: 	yulAssert(false, "auxdataloadn not implemented.");
188: }
189: 
190: void NoOutputAssembly::appendEOFCreate(ContainerID)
191: {
192: 	yulAssert(false, "eofcreate not implemented.");
193: 
194: }
195: void NoOutputAssembly::appendReturnContract(ContainerID)
196: {
197: 	yulAssert(false, "returncontract not implemented.");
198: }
199: 
200: NoOutputEVMDialect::NoOutputEVMDialect(EVMDialect const& _copyFrom):
201: 	EVMDialect(_copyFrom.evmVersion(), _copyFrom.eofVersion(), _copyFrom.providesObjectAccess())
202: {
203: 	for (auto& fun: m_functions)
204: 		if (fun)
205: 			modifyBuiltinToNoOutput(*fun);
206: }
207: 
208: BuiltinFunctionForEVM const& NoOutputEVMDialect::builtin(BuiltinHandle const& _handle) const
209: {
210: 	if (isVerbatimHandle(_handle))
211: 		// for verbatims the modification is performed lazily as they are stored in a lookup table fashion
212: 		if (
213: 			auto& builtin = m_verbatimFunctions[_handle.id];
214: 			!builtin
215: 		)
216: 		{
217: 			builtin = std::make_unique<BuiltinFunctionForEVM>(createVerbatimFunctionFromHandle(_handle));
218: 			modifyBuiltinToNoOutput(*builtin);
219: 		}
220: 	return EVMDialect::builtin(_handle);
221: }
```
2.
File Path: test/libsolidity/syntaxTests/inlineAssembly/solidity_keywords.sol
Code Snippet:
```

27:   let internal := 1
28:   let immutable := 1
29:   let import := 1
30:   let is := 1
31:   let library := 1
32:   let mapping := 1
33:   let memory := 1
34:   let modifier := 1
35:   let new := 1
36:   let override := 1
37:   let payable := 1
38:   let public := 1
39:   let pragma := 1
40:   let private := 1
41:   let pure := 1
42:   let receive := 1
43:   // return is a builtin in EVMDialect
44:   return(0, 0)
45:   let returns := 1
46:   let storage := 1
47:   let calldata := 1
48:   let struct := 1
49:   let throw := 1
50:   let try := 1
51:   // type shadows the Solidity function
52:   let unicode := 1
53:   let using := 1
54:   let view := 1
55:   let virtual := 1
56:   let while := 1
57:   let wei := 1
58:   let gwei := 1
59:   let ether := 1
60:   let seconds := 1
61:   let minutes := 1
62:   let hours := 1
63:   let days := 1
64:   let weeks := 1
65:   let years := 1
66:   let int := 1
67:   let uint := 1
68:   let bytes := 1
69:   // byte is a builtin in EVMDialect
70:   pop(byte(1, 1))
71:   let string := 1
72:   // address is a builtin in EVMDialect
73:   pop(address())
74:   let bool := 1
75:   let fixed := 1
76:   let ufixed := 1
77:   let after := 1
78:   let alias := 1
79:   let apply := 1
80:   let auto := 1
81:   // case is a Yul keyword
82:   let copyof := 1
83:   // default is a Yul keyword
84:   let define := 1
85:   let final := 1
86:   let implements := 1
87:   let in := 1
88:   let inline := 1
89:   // let is a Yul keyword
90:   let macro := 1
91:   let match := 1
92:   let mutable := 1
93:   let null := 1
94:   let of := 1
95:   let partial := 1
96:   let promise := 1
97:   let reference := 1
98:   let relocatable := 1
99:   let sealed := 1
100:   let sizeof := 1
101:   let static := 1
102:   let supports := 1
103:   // switch is a Yul keyword
104:   let typedef := 1
105:   let typeof := 1
106:   let unchecked := 1
107:   let var := 1
108:     }
109:   }
110: }

```
3.
File Path: libyul/backends/evm/EVMDialect.h
Code Snippet:
```
>
25: 
26: #include <libyul/backends/evm/AbstractAssembly.h>
27: #include <libyul/ASTForward.h>
28: #include <liblangutil/EVMVersion.h>
29: 
30: #include <map>
31: #include <set>
32: 
33: namespace solidity::yul
34: {
35: 
36: struct FunctionCall;
37: class Object;
38: 
39: /**
40:  * Context used during code generation.
41:  */
42: struct BuiltinContext
43: {
44: 	Object const* currentObject = nullptr;
45: 	/// Mapping from named objects to abstract assembly sub IDs.
46: 	std::map<std::string, AbstractAssembly::SubID> subIDs;
47: 
48: 	std::map<Scope::Function const*, AbstractAssembly::FunctionID> functionIDs;
49: };
50: 
51: struct BuiltinFunctionForEVM: public BuiltinFunction
52: {
53: 	std::optional<evmasm::Instruction> instruction;
54: 	/// Function to generate code for the given function call and append it to the abstract
55: 	/// assembly. Expects all non-literal arguments of the call to be on stack in reverse order
56: 	/// (i.e. right-most argument pushed first).
57: 	/// Expects the caller to set the source location.
58: 	std::function<void(FunctionCall const&, AbstractAssembly&, BuiltinContext&)> generateCode;
59: };
60: 
61: 
62: /**
63:  * Yul dialect for EVM as a backend.
64:  * The main difference is that the builtin functions take an AbstractAssembly for the
65:  * code generation.
66:  */
67: class EVMDialect: public Dialect
68: {
69: public:
70: 	/// Constructor, should only be used internally. Use the factory functions below.
71: 	EVMDialect(langutil::EVMVersion _evmVersion, std::optional<uint8_t> _eofVersion, bool _objectAccess);
72: 
73: 	std::optional<BuiltinHandle> findBuiltin(std::string_view _name) const override;
74: 
75: 	BuiltinFunctionForEVM const& builtin(BuiltinHandle const& _handle) const override;
76: 
77: 	bool reservedIdentifier(std::string_view _name) const override;
78: 
79: 	std::optional<BuiltinHandle> discardFunctionHandle() const override { return m_discardFunction; }
80: 	std::optional<BuiltinHandle> equalityFunctionHandle() const override { return m_equalityFunction; }
81: 	std::optional<BuiltinHandle> booleanNegationFunctionHandle() const override { return m_booleanNegationFunction; }
82: 	std::optional<BuiltinHandle> memoryStoreFunctionHandle() const override { return m_memoryStoreFunction; }
83: 	std::optional<BuiltinHandle> memoryLoadFunctionHandle() const override { return m_memoryLoadFunction; }
84: 	std::optional<BuiltinHandle> storageStoreFunctionHandle() const override { return m_storageStoreFunction; }
85: 	std::optional<BuiltinHandle> storageLoadFunctionHandle() const override { return m_storageLoadFunction; }
86: 	std::optional<BuiltinHandle> hashFunctionHandle() const override { return m_hashFunction; }
87: 
88: 	static EVMDialect const& strictAssemblyForEVM(langutil::EVMVersion _evmVersion, std::optional<uint8_t> _eofVersion);
89
```
4.
File Path: libyul/backends/evm/NoOutputAssembly.h
Code Snippet:
```
71: 	void appendJumpToIf(LabelID _labelId, JumpType _jumpType) override;
72: 
73: 	void appendAssemblySize() override;
74: 	std::pair<std::shared_ptr<AbstractAssembly>, SubID> createSubAssembly(bool _creation, std::string _name = "") override;
75: 	FunctionID registerFunction(uint8_t _args, uint8_t _rets) override;
76: 	void beginFunction(FunctionID) override;
77: 	void endFunction() override;
78: 	void appendFunctionCall(FunctionID _functionID) override;
79: 	void appendFunctionReturn() override;
80: 	void appendDataOffset(std::vector<SubID> const& _subPath) override;
81: 	void appendDataSize(std::vector<SubID> const& _subPath) override;
82: 	SubID appendData(bytes const& _data) override;
83: 
84: 	void appendToAuxiliaryData(bytes const&) override {}
85: 
86: 	void appendImmutable(std::string const& _identifier) override;
87: 	void appendImmutableAssignment(std::string const& _identifier) override;
88: 
89: 	void appendAuxDataLoadN(uint16_t) override;
90: 	void appendEOFCreate(ContainerID) override;
91: 	void appendReturnContract(ContainerID) override;
92: 
93: 	void markAsInvalid() override {}
94: 
95: 	langutil::EVMVersion evmVersion() const override { return m_evmVersion; }
96: 
97: private:
98: 	NoOutputAssemblyContext m_context = {};
99: 	int m_stackHeight = 0;
100: 	FunctionID m_currentFunctionID = 0;
101: 	langutil::EVMVersion m_evmVersion;
102: };
103: 
104: 
105: /**
106:  * EVM dialect that does not generate any code.
107:  */
108: class NoOutputEVMDialect: public EVMDialect
109: {
110: public:
111: 	explicit NoOutputEVMDialect(EVMDialect const& _copyFrom);
112: 
113: 	BuiltinFunctionForEVM const& builtin(BuiltinHandle const& _handle) const override;
114: };
115: 
116: 
117: }
```
5.
File Path: libyul/backends/evm/NoOutputAssembly.cpp
Code Snippet:
```
End function without begin function.");
155: 	auto const rets = m_context.functionSignatures.at(m_currentFunctionID).second;
156: 	yulAssert(rets == 0x80 || m_stackHeight == rets, "Stack height mismatch at function end.");
157: }
158: 
159: void NoOutputAssembly::appendDataOffset(std::vector<AbstractAssembly::SubID> const&)
160: {
161: 	appendInstruction(evmasm::Instruction::PUSH1);
162: }
163: 
164: void NoOutputAssembly::appendDataSize(std::vector<AbstractAssembly::SubID> const&)
165: {
166: 	appendInstruction(evmasm::Instruction::PUSH1);
167: }
168: 
169: AbstractAssembly::SubID NoOutputAssembly::appendData(bytes const&)
170: {
171: 	return 1;
172: }
173: 
174: 
175: void NoOutputAssembly::appendImmutable(std::string const&)
176: {
177: 	yulAssert(false, "loadimmutable not implemented.");
178: }
179: 
180: void NoOutputAssembly::appendImmutableAssignment(std::string const&)
181: {
182: 	yulAssert(false, "setimmutable not implemented.");
183: }
184: 
185: void NoOutputAssembly::appendAuxDataLoadN(uint16_t)
186: {
187: 	yulAssert(false, "auxdataloadn not implemented.");
188: }
189: 
190: void NoOutputAssembly::appendEOFCreate(ContainerID)
191: {
192: 	yulAssert(false, "eofcreate not implemented.");
193: 
194: }
195: void NoOutputAssembly::appendReturnContract(ContainerID)
196: {
197: 	yulAssert(false, "returncontract not implemented.");
198: }
199: 
200: NoOutputEVMDialect::NoOutputEVMDialect(EVMDialect const& _copyFrom):
201: 	EVMDialect(_copyFrom.evmVersion(), _copyFrom.eofVersion(), _copyFrom.providesObjectAccess())
202: {
203: 	for (auto& fun: m_functions)
204: 		if (fun)
205: 			modifyBuiltinToNoOutput(*fun);
206: }
207: 
208: BuiltinFunctionForEVM const& NoOutputEVMDialect::builtin(BuiltinHandle const& _handle) const
209: {
210: 	if (isVerbatimHandle(_handle))
211: 		// for verbatims the modification is performed lazily as they are stored in a lookup table fashion
212: 		if (
213: 			auto& builtin = m_verbatimFunctions[_handle.id];
214: 			!builtin
215: 		)
216: 		{
217: 			builtin = std::make_unique<BuiltinFunctionForEVM>(createVerbatimFunctionFromHandle(_handle));
218: 			modifyBuiltinToNoOutput(*builtin);
219: 		}
220: 	return EVMDialect::builtin(_handle);
221: }
```
6.
File Path: libyul/backends/evm/EVMDialect.cpp
Code Snippet:
```
	0,
417: 				EVMDialect::sideEffectsOfInstruction(evmasm::Instruction::RETURNCONTRACT),
418: 				ControlFlowSideEffects::fromInstruction(evmasm::Instruction::RETURNCONTRACT),
419: 				{LiteralKind::String, std::nullopt, std::nullopt},
420: 				[](
421: 					FunctionCall const& _call,
422: 					AbstractAssembly& _assembly,
423: 					BuiltinContext& context
424: 				) {
425: 					yulAssert(_call.arguments.size() == 3);
426: 					Literal const* literal = std::get_if<Literal>(&_call.arguments.front());
427: 					yulAssert(literal);
428: 					auto const formattedLiteral = formatLiteral(*literal);
429: 					yulAssert(!util::contains(formattedLiteral, '.'));
430: 					auto const* containerID = valueOrNullptr(context.subIDs, formattedLiteral);
431: 					yulAssert(containerID != nullptr);
432: 					yulAssert(*containerID <= std::numeric_limits<AbstractAssembly::ContainerID>::max());
433: 					_assembly.appendReturnContract(static_cast<AbstractAssembly::ContainerID>(*containerID));
434: 				}
435: 			));
436: 	}
437: 	yulAssert(
438: 		ranges::all_of(builtins, [](std::optional<BuiltinFunctionForEVM> const& _builtinFunction){
439: 			return !_builtinFunction || _builtinFunction->name.substr(0, "verbatim_"s.size()) != "verbatim_";
440: 		}),
441: 		"Builtin functions besides verbatim should not start with the verbatim_ prefix."
442: 	);
443: 	return builtins;
444: }
445: 
446: std::regex const& verbatimPattern()
447: {
448: 	std::regex static const pattern{"([1-9]?[0-9])i_([1-9]?[0-9])o"};
449: 	return pattern;
450: }
451: 
452: }
453: 
454: 
455: EVMDialect::EVMDialect(langutil::EVMVersion _evmVersion, std::optional<uint8_t> _eofVersion, bool _objectAccess):
456: 	m_objectAccess(_objectAccess),
457: 	m_evmVersion(_evmVersion),
458: 	m_eofVersion(_eofVersion),
459: 	m_functions(createBuiltins(_evmVersion, _eofVersion, _objectAccess)),
460: 	m_reserved(createReservedIdentifiers(_evmVersion, _eofVersion))
461: {
462: 	for (auto const& [index, maybeBuiltin]: m_functions | ranges::views::enumerate)
463: 		if (maybeBuiltin)
464: 			// ids are offset by the maximum number of verbatim functions
465: 			m_builtinFunctionsByName[maybeBuiltin->name] = BuiltinHandle{index + verbatimIDOffset};
466: 
467: 	m_discardFunction = findBuiltin("pop");
468: 	m_equalityFunction = findBuiltin("eq");
469: 	m_booleanNegationFunction = findBuiltin("iszero");
470: 	m_memoryStoreFunction = findBuiltin("mstore");
471: 	m_memoryLoadFunction = findBuiltin("mload");
472: 	m_storageStoreFunction = findBuiltin("sstore");
473: 	m_storageLoadFunction = findBuiltin("sload");
474: 	m_hashFunction = findBuiltin("keccak256");
475: }
476: 
477: std::optional<B
```
7.
File Path: libyul/AsmAnalysis.cpp
Code Snippet:
```
_location,
676: 			"\"" + _identifier.str() + "\" is not a valid identifier (contains consecutive dots)."
677: 		);
678: 
679: 	if (m_dialect.reservedIdentifier(_identifier.str()))
680: 		m_errorReporter.declarationError(
681: 			5017_error,
682: 			_location,
683: 			"The identifier \"" + _identifier.str() + "\" is reserved and can not be used."
684: 		);
685: }
686: 
687: bool AsmAnalyzer::validateInstructions(std::string const& _instructionIdentifier, langutil::SourceLocation const& _location)
688: {
689: 	// NOTE: This function uses the default EVM version instead of the currently selected one.
690: 	auto const& defaultEVMDialect = EVMDialect::strictAssemblyForEVM(EVMVersion{}, std::nullopt);
691: 	auto const builtinHandle = defaultEVMDialect.findBuiltin(_instructionIdentifier);
692: 	if (builtinHandle && defaultEVMDialect.builtin(*builtinHandle).instruction.has_value())
693: 		return validateInstructions(*defaultEVMDialect.builtin(*builtinHandle).instruction, _location);
694: 
695: 	// TODO: Change `prague()` to `EVMVersion{}` once EOF gets deployed
696: 	auto const& eofDialect = EVMDialect::strictAssemblyForEVM(EVMVersion::prague(), 1);
697: 	auto const eofBuiltinHandle = eofDialect.findBuiltin(_instructionIdentifier);
698: 	if (eofBuiltinHandle && eofDialect.builtin(*eofBuiltinHandle).instruction.has_value())
699: 		return validateInstructions(*eofDialect.builtin(*eofBuiltinHandle).instruction, _location);
700: 
701: 	return false;
702: }
703: 
704: bool AsmAnalyzer::validateInstructions(evmasm::Instruction _instr, SourceLocation const& _location)
705: {
706: 	// We assume that returndatacopy, returndatasize and staticcall are either all available
707: 	// or all not available.
708: 	yulAssert(m_evmVersion.supportsReturndata() == m_evmVersion.hasStaticCall(), "");
709: 	// Similarly we assume bitwise shifting and create2 go together.
710: 	yulAssert(m_evmVersion.hasBitwiseShifting() == m_evmVersion.hasCreate2(), "");
711: 
712: 	// These instructions are disabled in the dialect.
713: 	yulAssert(
714: 		_instr != evmasm::Instruction::JUMP &&
715: 		_instr != evmasm::Instruction::JUMPI &&
716: 		_instr != evmasm::Instruction::JUMPDEST,
717: 	"");
718: 
719: 	auto errorForVM = [&](ErrorId _errorId, std::string const& vmKindMessage) {
720: 		m_errorReporter.typeError(
721: 			_errorId,
722: 			_location,
723: 			fmt::format(
724: 				"The \"{instruction}\" instruction is {kind} VMs (you are currently compiling for \"{version}\").",
725: 				fmt::arg("instruction", boost::to_lower_copy(instructionInfo(_instr, m_evmVersion).name)),
726: 				fmt::arg("kind", vmKindMessage),
727: 				fmt::arg("version", m_evmVersion.name())
728: 			)
729: 		);
730: 	};
731: 
732: 	// The errors below are meant to be issued when processing
```
8.
File Path: libyul/backends/evm/EVMDialect.cpp
Code Snippet:
```
(_eofVersion),
459: 	m_functions(createBuiltins(_evmVersion, _eofVersion, _objectAccess)),
460: 	m_reserved(createReservedIdentifiers(_evmVersion, _eofVersion))
461: {
462: 	for (auto const& [index, maybeBuiltin]: m_functions | ranges::views::enumerate)
463: 		if (maybeBuiltin)
464: 			// ids are offset by the maximum number of verbatim functions
465: 			m_builtinFunctionsByName[maybeBuiltin->name] = BuiltinHandle{index + verbatimIDOffset};
466: 
467: 	m_discardFunction = findBuiltin("pop");
468: 	m_equalityFunction = findBuiltin("eq");
469: 	m_booleanNegationFunction = findBuiltin("iszero");
470: 	m_memoryStoreFunction = findBuiltin("mstore");
471: 	m_memoryLoadFunction = findBuiltin("mload");
472: 	m_storageStoreFunction = findBuiltin("sstore");
473: 	m_storageLoadFunction = findBuiltin("sload");
474: 	m_hashFunction = findBuiltin("keccak256");
475: }
476: 
477: std::optional<BuiltinHandle> EVMDialect::findBuiltin(std::string_view _name) const
478: {
479: 	if (m_objectAccess && _name.substr(0, "verbatim_"s.size()) == "verbatim_")
480: 	{
481: 		std::smatch match;
482: 		std::string name(_name.substr("verbatim_"s.size()));
483: 		if (regex_match(name, match, verbatimPattern()))
484: 			return verbatimFunction(stoul(match[1]), stoul(match[2]));
485: 	}
486: 
487: 	if (
488: 		auto it = m_builtinFunctionsByName.find(_name);
489: 		it != m_builtinFunctionsByName.end()
490: 	)
491: 		return it->second;
492: 
493: 	return std::nullopt;
494: }
495: 
496: BuiltinFunctionForEVM const& EVMDialect::builtin(BuiltinHandle const& _handle) const
497: {
498: 	if (isVerbatimHandle(_handle))
499: 	{
500: 		yulAssert(_handle.id < verbatimIDOffset);
501: 		auto const& verbatimFunctionPtr = m_verbatimFunctions[_handle.id];
502: 		yulAssert(verbatimFunctionPtr);
503: 		return *verbatimFunctionPtr;
504: 	}
505: 
506: 	yulAssert(_handle.id - verbatimIDOffset < m_functions.size());
507: 	auto const& maybeBuiltin = m_functions[_handle.id - verbatimIDOffset];
508: 	yulAssert(maybeBuiltin.has_value());
509: 	return *maybeBuiltin;
510: }
511: 
512: 
513: bool EVMDialect::reservedIdentifier(std::string_view _name) const
514: {
515: 	if (m_objectAccess)
516: 		if (_name.substr(0, "verbatim"s.size()) == "verbatim")
517: 			return true;
518: 	return m_reserved.count(_name) != 0;
519: }
520: 
521: EVMDialect const& EVMDialect::strictAssemblyForEVM(langutil::EVMVersion _evmVersion, std::optional<uint8_t> _eofVersion)
522: {
523: 	static std::map<std::pair<langutil::EVMVersion, std::optional<uint8_t>>, std::unique_ptr<EVMDialect const>> dialect
```
9.
File Path: libyul/optimiser/OptimizerUtilities.cpp
Code Snippet:
```
m/EVMDialect.h>
24: 
25: #include <libyul/Dialect.h>
26: #include <libyul/AST.h>
27: 
28: #include <liblangutil/Token.h>
29: #include <libsolutil/CommonData.h>
30: 
31: #include <range/v3/action/remove_if.hpp>
32: 
33: using namespace solidity;
34: using namespace solidity::langutil;
35: using namespace solidity::util;
36: using namespace solidity::yul;
37: 
38: namespace
39: {
40: 
41: bool hasLeadingOrTrailingDot(std::string_view const _s)
42: {
43: 	yulAssert(!_s.empty());
44: 	return _s.front() == '.' || _s.back() == '.';
45: }
46: 
47: }
48: 
49: void yul::removeEmptyBlocks(Block& _block)
50: {
51: 	auto isEmptyBlock = [](Statement const& _st) -> bool {
52: 		return std::holds_alternative<Block>(_st) && std::get<Block>(_st).statements.empty();
53: 	};
54: 	ranges::actions::remove_if(_block.statements, isEmptyBlock);
55: }
56: 
57: bool yul::isRestrictedIdentifier(Dialect const& _dialect, YulName const& _identifier)
58: {
59: 	return _identifier.empty() || hasLeadingOrTrailingDot(_identifier.str()) || TokenTraits::isYulKeyword(_identifier.str()) || _dialect.reservedIdentifier(_identifier.str());
60: }
61: 
62: std::optional<evmasm::Instruction> yul::toEVMInstruction(Dialect const& _dialect, YulName const& _name)
63: {
64: 	if (auto const* dialect = dynamic_cast<EVMDialect const*>(&_dialect))
65: 		if (std::optional<BuiltinHandle> const builtinHandle = dialect->findBuiltin(_name.str()))
66: 			return dialect->builtin(*builtinHandle).instruction;
67: 	return std::nullopt;
68: }
69: 
70: langutil::EVMVersion const yul::evmVersionFromDialect(Dialect const& _dialect)
71: {
72: 	if (auto const* dialect = dynamic_cast<EVMDialect const*>(&_dialect))
73: 		return dialect->evmVersion();
74: 	return langutil::EVMVersion();
75: }
76: 
77: void StatementRemover::operator()(Block& _block)
78: {
79: 	util::iterateReplacing(
80: 		_block.statements,
81: 		[&](Statement& _statement) -> std::optional<std::vector<Statement>>
82: 		{
83: 			if (m_toRemove.count(&_statement))
84: 				return {std::vector<Statement>{}};
85: 			else
86: 				return std::nullopt;
87: 		}
88: 	);
89: 	ASTModifier::operator()(_block);
90: }
```
10.
File Path: test/tools/yulInterpreter/Interpreter.cpp
Code Snippet:
```
	if (!m_scope->subScopes.count(&_block))
268: 		m_scope->subScopes[&_block] = std::make_unique<Scope>(Scope{
269: 			{},
270: 			{},
271: 			m_scope
272: 		});
273: 	m_scope = m_scope->subScopes[&_block].get();
274: }
275: 
276: void Interpreter::leaveScope()
277: {
278: 	for (auto const& [var, funDeclaration]: m_scope->names)
279: 		if (!funDeclaration)
280: 			m_variables.erase(var);
281: 	m_scope = m_scope->parent;
282: 	yulAssert(m_scope, "");
283: }
284: 
285: void Interpreter::incrementStep()
286: {
287: 	m_state.numSteps++;
288: 	if (m_state.maxSteps > 0 && m_state.numSteps >= m_state.maxSteps)
289: 	{
290: 		m_state.trace.emplace_back("Interpreter execution step limit reached.");
291: 		BOOST_THROW_EXCEPTION(StepLimitReached());
292: 	}
293: }
294: 
295: void ExpressionEvaluator::operator()(Literal const& _literal)
296: {
297: 	incrementStep();
298: 	setValue(_literal.value.value());
299: }
300: 
301: void ExpressionEvaluator::operator()(Identifier const& _identifier)
302: {
303: 	solAssert(m_variables.count(_identifier.name), "");
304: 	incrementStep();
305: 	setValue(m_variables.at(_identifier.name));
306: }
307: 
308: void ExpressionEvaluator::operator()(FunctionCall const& _funCall)
309: {
310: 	std::vector<std::optional<LiteralKind>> const* literalArguments = nullptr;
311: 	if (std::optional<BuiltinHandle> builtinHandle = m_dialect.findBuiltin(_funCall.functionName.name.str()))
312: 		if (
313: 			auto const& args = m_dialect.builtin(*builtinHandle).literalArguments;
314: 			!args.empty()
315: 		)
316: 			literalArguments = &args;
317: 	evaluateArgs(_funCall.arguments, literalArguments);
318: 
319: 	if (EVMDialect const* dialect = dynamic_cast<EVMDialect const*>(&m_dialect))
320: 	{
321: 		if (std::optional<BuiltinHandle> builtinHandle = dialect->findBuiltin(_funCall.functionName.name.str()))
322: 		{
323: 			auto const& fun = dialect->builtin(*builtinHandle);
324: 			EVMInstructionInterpreter interpreter(dialect->evmVersion(), m_state, m_disableMemoryTrace);
325: 
326: 			u256 const value = interpreter.evalBuiltin(fun, _funCall.arguments, values());
327: 
328: 			if (
329: 				!m_disableExternalCalls &&
330: 				fun.instruction &&
331: 				evmasm::isCallInstruction(*fun.instruction)
332: 			)
333: 				runExternalCall(*fun.instruction);
334: 
335: 			setValue(value);
336: 			return;
337: 		}
338: 	}
339: 
340: 	Scope* scope = &m_scope;
341: 	for (; scope; scope = scope->parent)
342: 		if (scope->names.count(_funCall.functionName.name))
343: 			break;
344: 	yulAssert(scope, "");
345: 
346: 	FunctionDefinition const* fun = scope->names.at(_funCall.functionName.name);
347: 	yulAssert(fun, "Function not found.");
348: 
```
<END_OF_CONTEXT>
<START_OF_USER_PROMPT>

List every function **definition** (not declaration)  
where the **body** contains a **CallExpr** to  
`EVMDialect::builtin( … )`  
- exclude any occurrence inside  
  - return statements  
  - function signatures  
  - comments or string literals  
For each hit, output only the file name of this function + function signature + its body.  
If no such caller exists, reply “None”.

<END_OF_USER_PROMPT>
